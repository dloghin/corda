<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ComplexMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>MagicNumber:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$20</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$ fun recordUsedInstrumentedCallStack()</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$val instrumentClassMethods = clazz.methods.filter { it.name == "instrumentClass" } // TODO this is very brittle, we want to match on a specific instrumentClass() function. We could use the function signature, but that may change between versions anyway. Why is this function overloaded?? instrumentClassMethods[0].insertBefore( "$hookClassName.${::recordScannedClass.name}(className);" )</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$println("Instrumented classes: ${classRecorder.instrumentedClasses.size}") classRecorder.instrumentedClasses.forEach { println(" $it") } println("Used instrumented classes: ${classRecorder.usedInstrumentedClasses.size}") classRecorder.usedInstrumentedClasses.forEach { println(" $it") } println("Scanned classes: ${classRecorder.scannedClasses.size}") classRecorder.scannedClasses.keys.take(20).forEach { println(" $it") } println(" (...)") val scannedTree = PackageTree.fromStrings(classRecorder.scannedClasses.keys.toList(), '/') val instrumentedTree = PackageTree.fromStrings(classRecorder.instrumentedClasses.keys.toList(), '/') val alwaysExclude = arguments.alwaysExcluded?.let { PackageTree.fromStrings(it, arguments.separator) } val alwaysExcludedTree = alwaysExclude?.let { instrumentedTree.truncate(it) } ?: instrumentedTree println("Suggested exclude globs:") val truncate = arguments.truncate?.let { PackageTree.fromStrings(it, arguments.separator) } // The separator append is a hack, it causes a package with an empty name to be added to the exclude tree, // which practically causes that level of the tree to be always expanded in the output globs. val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) } val truncatedTree = truncate?.let { scannedTree.truncate(it) } ?: scannedTree val expandedTree = expand?.let { alwaysExcludedTree.merge(it) } ?: alwaysExcludedTree val globs = truncatedTree.toGlobs(expandedTree) globs.forEach { println(" $it") } println("Quasar exclude expression:") println(" x(${globs.joinToString(";")})")</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) }</ID>
    <ID>NestedBlockDepth:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>TooGenericExceptionCaught:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$throwable: Throwable</ID>
  </Whitelist>
</SmellBaseline>
