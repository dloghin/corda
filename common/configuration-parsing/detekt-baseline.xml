<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>MatchingDeclarationName:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Describer</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Schema : ValidatorDescriber</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Validator : Validator</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Describer$ fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue = { value -&gt; ConfigValueFactory.fromAnyRef(value.toString()) }): ConfigValue?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Definition&lt;TYPE&gt; : MetadataValidatorExtractorDescriberParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Metadata</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$Single&lt;TYPE&gt; : Definition</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$override</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun boolean(key: String, sensitive: Boolean = false): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun double(key: String, sensitive: Boolean = false): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun duration(key: String, sensitive: Boolean = false): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun float(key: String, sensitive: Boolean = false): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun int(key: String, sensitive: Boolean = false): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun nestedObject(key: String, schema: Schema? = null, sensitive: Boolean = false): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun string(key: String, sensitive: Boolean = false): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Float, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of(key, Float::class.javaObjectType.simpleName, "Provided value exceeds Float range."))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Int, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of("Provided value exceeds Integer range [${Int.MIN_VALUE}, ${Int.MAX_VALUE}].", key, Int::class.javaObjectType.simpleName))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, builder: Property.Definition.Companion.() -&gt; Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, properties: Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(vararg properties: Property.Definition&lt;*&gt;, name: String? = null): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String? = null, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun boolean(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun double(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun duration(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun float(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun int(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun long(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun nestedObject(schema: Schema? = null, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun string(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ protected abstract fun parseValid(configuration: Config): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$abstract</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$final override fun parse(configuration: Config, options: Configuration.Validation.Options): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadPath : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MalformedStructure : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MissingValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$Unknown : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$UnsupportedVersion : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$WrongType : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal abstract fun with(keyName: String = this.keyName ?: UNKNOWN, typeName: String = this.typeName ?: UNKNOWN): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal fun withContainingPathPrefix(vararg containingPath: String): Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$sealed</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun with(keyName: String, typeName: String): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun with(keyName: String, typeName: String): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun with(keyName: String, typeName: String): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun with(keyName: String, typeName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun forKey(keyName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown.Companion$fun of(keyName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): Unknown</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.UnsupportedVersion$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun with(keyName: String, typeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun forKey(keyName: String, expectedTypeName: String, actualTypeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value$Parser&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueIn(configuration: Config): TYPE</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueInOrNull(configuration: Config): TYPE?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Parser$ fun parse(configuration: Config, options: Configuration.Validation.Options = Configuration.Validation.Options.defaults): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Version.Extractor.Companion$ fun fromPath(versionPath: String, versionDefaultValue: Int = DEFAULT_VERSION_VALUE): Configuration.Version.Extractor</ID>
    <ID>MaxLineLength:Properties.kt$DelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun valueIn(configuration: Config): List&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$return delegate.schema?.let { schema -&gt; valueDescription(valueIn(configuration).asSequence().map { element -&gt; valueDescription(element, serialiseValue) }.map { it as ConfigObject }.map(ConfigObject::toConfig).map { schema.describe(it, serialiseValue) }.toList(), serialiseValue) } ?: valueDescription(valueIn(configuration), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$val errors = list.asSequence().map { configObject(key to ConfigValueFactory.fromAnyRef(it)) }.mapIndexed { index, value -&gt; delegate.validate(value.toConfig(), options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$errors += convert.invoke(delegate.valueIn(target)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun &lt;M&gt; mapValid(mappedTypeName: String, convert: (MAPPED) -&gt; Valid&lt;M&gt;): Configuration.Property.Definition.Standard&lt;M&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override val typeName: String = if (super.typeName == "#$mappedTypeName") super.typeName else "$mappedTypeName(${super.typeName})"</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$errors += convert.invoke(delegate.valueIn(target)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$errors += valueIn(target).asSequence().map { element -&gt; element as ConfigObject }.map(ConfigObject::toConfig).mapIndexed { index, targetConfig -&gt; schema.validate(targetConfig, options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$val elementsDescription = valueIn(configuration).asSequence().map { it as ConfigObject }.map(ConfigObject::toConfig).map { delegate.schema.describe(it, serialiseValue) }.toList()</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$internal</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$return invalid(ConfigException.WrongType(target.origin(), key, Long::class.javaObjectType.simpleName, Double::class.javaObjectType.simpleName).toValidationError(key, typeName))</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun withDefaultValue(defaultValue: TYPE): Configuration.Property.Definition&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$val missingValueError = errors.asSequence().filterIsInstance&lt;Configuration.Validation.Error.MissingValue&gt;().filter { it.pathAsString == key }.singleOrNull()</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun validate(target: Config, options: Configuration.Validation.Options): Valid&lt;Config&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$private</ID>
    <ID>MaxLineLength:Properties.kt$RequiredDelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$errors += nestedSchema.validate(nestedConfig, options).errors.map { error -&gt; error.withContainingPathPrefix(*key.split(".").toTypedArray()) }</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$internal open</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$return schema?.describe(configuration.getConfig(key), serialiseValue) ?: valueDescription(valueIn(configuration), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$private</ID>
    <ID>MaxLineLength:Properties.kt$private fun isErrorExpected(error: ConfigException)</ID>
    <ID>MaxLineLength:Properties.kt$private val expectedExceptionTypes = setOf(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigException.BadPath::class, ConfigException.Parse::class)</ID>
    <ID>MaxLineLength:Schema.kt$Schema$internal</ID>
    <ID>MaxLineLength:Schema.kt$Schema$return properties.asSequence().map { it.key to it.describe(configuration, serialiseValue) }.filter { it.second != null }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$throw IllegalArgumentException("More than one property was found for keys ${invalid.keys.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val invalid = properties.groupBy(Configuration.Property.Definition&lt;*&gt;::key).mapValues { entry -&gt; entry.value.size }.filterValues { propertiesForKey -&gt; propertiesForKey &gt; 1 }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val nestedProperties = (properties + properties.flatMap { it.schema?.properties ?: emptySet() }).asSequence().distinctBy(Configuration.Property.Definition&lt;*&gt;::schema)</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val root = properties.asSequence().map { it.key to ConfigValueFactory.fromAnyRef(it.typeName) }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override fun withDefaultValue(defaultValue: TYPE): PropertyDelegate&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String?, prefix: String?, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun boolean(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun double(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun duration(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun float(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun int(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun long(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun nestedObject(schema: Configuration.Schema?, key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun string(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Optional$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Optional&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Required$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Required&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.RequiredList&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Single$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Single&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Standard&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun list(): PropertyDelegate.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Standard&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Required&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; Configuration.Property.Definition.Single&lt;TYPE&gt;.listOrEmpty(): Configuration.Property.Definition&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; PropertyDelegate.Single&lt;TYPE&gt;.listOrEmpty(): PropertyDelegate&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified ENUM : Enum&lt;ENUM&gt;, VALUE : Any&gt; Configuration.Specification&lt;VALUE&gt;.enum(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified NESTED : Any&gt; Configuration.Specification&lt;*&gt;.nested(specification: Configuration.Specification&lt;NESTED&gt;, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;NESTED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$internal fun Config.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:Utils.kt$internal fun ConfigValue.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:VersionExtractor.kt$VersionExtractor.Spec$private</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry$value?.let { valid(it) } ?: invalid&lt;Configuration.Specification&lt;VALUE&gt;, Configuration.Validation.Error&gt;(Configuration.Validation.Error.UnsupportedVersion.of(version))</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry&lt;VALUE&gt; : </ID>
    <ID>NewLineAtEndOfFile:Configuration.kt$net.corda.common.configuration.parsing.internal.Configuration.kt</ID>
    <ID>NewLineAtEndOfFile:Properties.kt$net.corda.common.configuration.parsing.internal.Properties.kt</ID>
    <ID>NewLineAtEndOfFile:Schema.kt$net.corda.common.configuration.parsing.internal.Schema.kt</ID>
    <ID>NewLineAtEndOfFile:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>NewLineAtEndOfFile:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>NewLineAtEndOfFile:VersionExtractor.kt$net.corda.common.configuration.parsing.internal.versioned.VersionExtractor.kt</ID>
    <ID>NewLineAtEndOfFile:VersionedSpecificationRegistry.kt$net.corda.common.configuration.parsing.internal.versioned.VersionedSpecificationRegistry.kt</ID>
    <ID>SpreadOperator:Configuration.kt$Configuration.Validation.Error$(*(containingPath.toList() + this.containingPath).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$FunctionalListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$ListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$StandardProperty$(*key.split(".").toTypedArray())</ID>
    <ID>TooManyFunctions:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>TooManyFunctions:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>WildcardImport:Configuration.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:Properties.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:Utils.kt$import com.typesafe.config.*</ID>
  </Whitelist>
</SmellBaseline>
