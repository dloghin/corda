<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>ComplexMethod:FlattenedList.kt$FlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>ComplexMethod:MappedList.kt$MappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:ReplayedList.kt$ReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>LongMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.01</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.18</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.31</ID>
    <ID>MaxLineLength:AggregatedList.kt$AggregatedList&lt;A, E : Any, K : Any&gt; : TransformationList</ID>
    <ID>MaxLineLength:AssociatedList.kt$AssociatedList&lt;K, out A, B&gt; : ReadOnlyBackedObservableMapBase</ID>
    <ID>MaxLineLength:ChosenList.kt$ChosenList&lt;E&gt; : ObservableListBase</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList$val permutedOffset = (if (permutedListIndex == 0) 0 else newSubNestedIndexOffsets[permutedListIndex - 1])</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList${ // If a nested element is updated we simply propagate the update by offsetting the nested element index // by the startingOffsetOf the nested list. val listIndex = indexMap[wrapped]!!.first val startingOffset = startingOffsetOf(listIndex) for (i in change.from until change.to) { nextUpdate(startingOffset + i) } }</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:ContractStateModel.kt$ContractStateModel$val cashStates: ObservableList&lt;StateAndRef&lt;Cash.State&gt;&gt; = cashStatesDiff.fold(FXCollections.observableArrayList()) { list: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;, (added, removed) -&gt; list.removeIf { it in removed } list.addAll(added) }.distinctBy { it.ref }</ID>
    <ID>MaxLineLength:ExchangeRateModel.kt$ExchangeRate$ fun exchangeAmount(amount: Amount&lt;Currency&gt;, to: Currency)</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList${ // TODO this assumes that if wasAdded() == true then we are adding elements to the getFrom() position val removeStart = c.from val removeRange = c.removed.size val removeEnd = c.from + removeRange val iterator = indexMap.iterator() for (entry in iterator) { val (wrapped, pair) = entry val (index, listener) = pair if (index &gt;= removeStart) { if (index &lt; removeEnd) { wrapped.observableValue.removeListener(listener) iterator.remove() } else { // Shift indices entry.setValue(Pair(index - removeRange, listener)) } } } nextRemove(removeStart, removed.map { it.value }) }</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:MapValuesList.kt$MapValuesList.Companion$val backingList = FXCollections.observableArrayList&lt;Map.Entry&lt;K, A&gt;&gt;(sourceMap.entries.sortedBy { it.key!!.hashCode() })</ID>
    <ID>MaxLineLength:MappedList.kt$MappedList&lt;A, B&gt; : TransformationList</ID>
    <ID>MaxLineLength:Models.kt$Models</ID>
    <ID>MaxLineLength:NetworkIdentityModel.kt$NetworkIdentityModel$val notaries = ChosenList(rpcProxy.map { FXCollections.observableList(it?.notaryIdentities() ?: emptyList()) }, "notaries")</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE))</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val stateMachineTransactionMapping: Observable&lt;StateMachineTransactionMapping&gt; = stateMachineTransactionMappingSubject</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel${ rpc = ReconnectingCordaRPCOps(nodeHostAndPort, username, password) proxyObservable.value = rpc // Vault snapshot (force single page load with MAX_PAGE_SIZE) + updates val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE)) val unconsumedStates = statesSnapshot.states.filterIndexed { index, _ -&gt; statesSnapshot.statesMetadata[index].status == Vault.StateStatus.UNCONSUMED }.toSet() val consumedStates = statesSnapshot.states.toSet() - unconsumedStates val initialVaultUpdate = Vault.Update(consumedStates, unconsumedStates, references = emptySet()) vaultUpdates.startWith(initialVaultUpdate).subscribe(vaultUpdatesSubject::onNext) // Transactions val (transactions, newTransactions) = rpc.internalVerifiedTransactionsFeed() newTransactions.startWith(transactions).subscribe(transactionsSubject::onNext) // SM -&gt; TX mapping val (smTxMappings, futureSmTxMappings) = rpc.stateMachineRecordedTransactionMappingFeed() futureSmTxMappings.startWith(smTxMappings).subscribe(stateMachineTransactionMappingSubject::onNext) // Parties on network val (parties, futurePartyUpdate) = rpc.networkMapFeed() futurePartyUpdate.startWith(parties.map(MapChange::Added)).subscribe(networkMapSubject::onNext) val stateMachines = rpc.stateMachinesSnapshot() notaryIdentities = rpc.notaryIdentities() // Extract the flow tracking stream // TODO is there a nicer way of doing this? Stream of streams in general results in code like this... // TODO `progressTrackingSubject` doesn't seem to be used anymore - should it be removed? val currentProgressTrackerUpdates = stateMachines.mapNotNull { stateMachine -&gt; ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachine) } val futureProgressTrackerUpdates = stateMachineUpdatesSubject.map { stateMachineUpdate -&gt; if (stateMachineUpdate is StateMachineUpdate.Added) { ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachineUpdate.stateMachineInfo) ?: Observable.empty&lt;ProgressTrackingEvent&gt;() } else { Observable.empty&lt;ProgressTrackingEvent&gt;() } } // We need to retry, because when flow errors, we unsubscribe from progressTrackingSubject. So we end up with stream of state machine updates and no progress trackers. futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject) }</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$ProgressTrackingEvent.Companion$future.map { ProgressTrackingEvent(stateMachine.id, it) }.startWith(ProgressTrackingEvent(stateMachine.id, current))</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;A, K&gt; Observable&lt;A&gt;.recordAsAssociation(toKey: (A) -&gt; K, merge: (K, oldValue: A, newValue: A) -&gt; A = { _, _, newValue -&gt; newValue }): ObservableMap&lt;K, A&gt;</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;T, R&gt; Observable&lt;T&gt;.fold(accumulator: R, folderFun: (R, T) -&gt; Unit): R</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;A&gt; Collection&lt;ObservableValue&lt;out A&gt;&gt;.sequence(): ObservableList&lt;A&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any, B&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K, assemble: (K, A) -&gt; B): ObservableMap&lt;K, ObservableList&lt;B&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K): ObservableMap&lt;K, ObservableList&lt;A&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$Pair(left, ChosenList(rightValue.map { it ?: FXCollections.emptyObservableList() }, "ChosenList from leftOuterJoin"))</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$return AssociatedList(AggregatedList(this, toKey) { key, members -&gt; Pair(key, members) }, { it.first }) { key, pair -&gt; pair.second.map { assemble(key, it) } }</ID>
    <ID>MaxLineLength:ObservableUtilities.kt${ //TODO This is a tactical work round for an issue with SAM conversion (https://youtrack.jetbrains.com/issue/ALL-1552) so that the M10 explorer works. return uncheckedCast(uncheckedCast&lt;Any, ObservableList&lt;A?&gt;&gt;(this).filtered { t -&gt; t != null }) }</ID>
    <ID>MaxLineLength:ReplayedList.kt$ReplayedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventSinkDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventStreamDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObjectPropertyDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListReadOnlyDelegate&lt;M : Any, out T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObserverDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$SubjectDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$WritableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>NestedBlockDepth:AggregatedList.kt$AggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>NestedBlockDepth:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>NewLineAtEndOfFile:ChosenList.kt$net.corda.client.jfx.utils.ChosenList.kt</ID>
    <ID>NewLineAtEndOfFile:ModelsUtils.kt$net.corda.client.jfx.model.ModelsUtils.kt</ID>
    <ID>NewLineAtEndOfFile:NodeMonitorModel.kt$net.corda.client.jfx.model.NodeMonitorModel.kt</ID>
    <ID>NewLineAtEndOfFile:TrackedDelegate.kt$net.corda.client.jfx.model.TrackedDelegate.kt</ID>
    <ID>TooGenericExceptionCaught:NodeMonitorModel.kt$NodeMonitorModel$e: Exception</ID>
    <ID>TooManyFunctions:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>TooManyFunctions:ReadOnlyBackedObservableMapBase.kt$ReadOnlyBackedObservableMapBase&lt;K, A, B&gt; : ObservableMap</ID>
    <ID>WildcardImport:NetworkIdentityModel.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NodeMonitorModel.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:TransactionDataModel.kt$import net.corda.core.contracts.*</ID>
  </Whitelist>
</SmellBaseline>
