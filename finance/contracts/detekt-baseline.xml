<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ComplexMethod:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: Fix addl period logic</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: The rest.</ID>
    <ID>ForbiddenComment:Cash.kt$Cash$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Consider how to handle the case of mistaken issuances, or other need to patch.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Generalise the notion of an owned instrument into a superclass/supercontract. Consider composition vs inheritance.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Think about how to evolve contracts over time with new commands.</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$// TODO: Make Calendar data come from an oracle</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$Frequency$// TODO: Revisit post-Vega and see if annualCompoundCount is still needed.</ID>
    <ID>ForbiddenComment:Obligation.kt$Obligation$// TODO: Handle proxies nominated by parties, i.e. a central clearing service</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: Check that re-running this on the same transaction multiple times does the right thing.</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions exiting inputs from</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions spending inputs from</ID>
    <ID>LongParameterList:BusinessCalendar.kt$BusinessCalendar.Companion$(startDate: LocalDate, period: Frequency, calendar: BusinessCalendar = EMPTY, dateRollConvention: DateRollConvention = DateRollConvention.Following, noOfAdditionalPeriods: Int = Integer.MAX_VALUE, endDate: LocalDate? = null, periodOffset: Int? = null)</ID>
    <ID>LongParameterList:Cash.kt$Cash$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amount: Amount&lt;T&gt;, to: AbstractParty, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$30.0</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$360.0</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.BiWeekly$26</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Daily$365</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Monthly$12</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Quarterly$3</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Quarterly$4</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.SemiAnnual$6</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Weekly$52</ID>
    <ID>MagicNumber:Obligation.kt$Obligation.Terms$30</ID>
    <ID>MaxLineLength:BusinessCalendar.kt$BusinessCalendar$operator fun plus(other: BusinessCalendar): BusinessCalendar</ID>
    <ID>MaxLineLength:BusinessCalendar.kt$BusinessCalendar.Companion$dcbDay == DayCountBasisDay.D30 &amp;&amp; dcbYear == DayCountBasisYear.Y360 -&gt; ((endDate.year - startDate.year) * 360.0 + (endDate.monthValue - startDate.monthValue) * 30.0 + endDate.dayOfMonth - startDate.dayOfMonth).toInt()</ID>
    <ID>MaxLineLength:Cash.kt$ @Throws(IllegalArgumentException::class) internal inline fun &lt;reified T : MoveCommand&gt; verifyFlattenedMoveCommand(inputs: List&lt;OwnableState&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;) : MoveCommand</ID>
    <ID>MaxLineLength:Cash.kt$Cash$ fun generateIssue(tx: TransactionBuilder, tokenDef: Issued&lt;Currency&gt;, pennies: Long, owner: AbstractParty, notary: Party)</ID>
    <ID>MaxLineLength:Cash.kt$Cash$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:Cash.kt$Cash$override</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group")</ID>
    <ID>MaxLineLength:Cash.kt$Cash${ val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group") val outputAmount = outputs.sumCashOrZero(Issued(issuer, currency)) // If we want to remove cash from the ledger, that must be signed for by the issuer. // A mis-signed or duplicated exit command will just be ignored here and result in the exit amount being zero. val exitKeys: Set&lt;PublicKey&gt; = inputs.flatMap { it.exitKeys }.toSet() val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key } val amountExitingLedger = exitCommand?.value?.amount ?: Amount(0, Issued(issuer, currency)) requireThat { "there are no zero sized inputs" using inputs.none { it.amount.quantity == 0L } "for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}" using (inputAmount == outputAmount + amountExitingLedger) } verifyFlattenedMoveCommand&lt;Commands.Move&gt;(inputs, tx.commands) }</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(party: AbstractParty)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun withDeposit(deposit: PartyAndReference): Cash.State</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$override</ID>
    <ID>MaxLineLength:Cash.kt$commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;</ID>
    <ID>MaxLineLength:Cash.kt$internal</ID>
    <ID>MaxLineLength:Cash.kt$internal inline</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states", indexes = [Index(name = "ccy_code_idx", columnList = "ccy_code"), Index(name = "pennies_idx", columnList = "pennies")])</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper : Contract</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$"the transaction is signed by the owner of the CP" using (input.owner.owningKey in command.signers)</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$val time = timeWindow?.fromTime ?: throw IllegalArgumentException("Redemptions must have a time-window")</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.Commands$Issue : TypeOnlyCommandDataCommands</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$// Although kotlin is smart enough not to need these, as we are using the ICommercialPaperState, we need to declare them explicitly for use later, override fun withOwner(newOwner: AbstractParty): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun toString()</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun withFaceValue(newFaceValue: Amount&lt;Issued&lt;Currency&gt;&gt;): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun withMaturityDate(newMaturityDate: Instant): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1.PersistentCommercialPaperState$@Table(name = "cp_states", indexes = [Index(name = "ccy_code_index", columnList = "ccy_code"), Index(name = "maturity_index", columnList = "maturity_instant"), Index(name = "face_value_index", columnList = "face_value")])</ID>
    <ID>MaxLineLength:FinanceTypes.kt$DateRollConvention</ID>
    <ID>MaxLineLength:FinanceTypes.kt$DealState$ fun generateAgreement(notary: Party): TransactionBuilder</ID>
    <ID>MaxLineLength:FinanceTypes.kt$Tenor$return BusinessCalendar.calculateDaysBetween(startDate, adjustedMaturityDate, DayCountBasisYear.Y360, DayCountBasisDay.DActual)</ID>
    <ID>MaxLineLength:FinanceTypes.kt$Tenor$val match = regex.matchEntire(name)?.groupValues ?: throw IllegalArgumentException("Unrecognised tenor name: $name")</ID>
    <ID>MaxLineLength:Obligation.kt$ fun &lt;P : AbstractParty, T : Any&gt; sumAmountsDue(balances: Map&lt;Pair&lt;P, P&gt;, Amount&lt;T&gt;&gt;): Map&lt;P, Long&gt;</ID>
    <ID>MaxLineLength:Obligation.kt$ fun &lt;P : Any&gt; extractAmountsDue(product: Obligation.Terms&lt;P&gt;, states: Iterable&lt;Obligation.State&lt;P&gt;&gt;): Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"amount in settle command ${command.value.amount} matches settled total $totalAmountSettled" using (command.value.amount == totalAmountSettled)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"amounts paid must match recipients to settle" using inputs.map { it.owner }.containsAll(amountReceivedByOwner.keys)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"output state corresponds exactly to input state, with lifecycle changed" using (expectedOutput == actualOutput)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$// Insist that we can be the only contract consuming inputs, to ensure no other contract can think it's being // settled as well "all move commands relate to this contract" using (moveCommands.map { it.value.contract } .all { it == null || it == this@Obligation.javaClass }) // Settle commands exclude all other commands, so we don't need to check for contracts moving at the same // time. "amounts paid must match recipients to settle" using inputs.map { it.owner }.containsAll(amountReceivedByOwner.keys) "amount in settle command ${command.value.amount} matches settled total $totalAmountSettled" using (command.value.amount == totalAmountSettled) "signatures are present from all obligors" using command.signers.containsAll(requiredSigners) "there are no zero sized inputs" using inputs.none { it.amount.quantity == 0L } "at obligor $obligor the obligations after settlement balance" using (inputAmount == outputAmount + Amount(totalPenniesSettled, groupingKey))</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$NetType.CLOSE_OUT -&gt; require(command.signers.intersect(involvedParties).isNotEmpty()) { "any involved party has signed" }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$NetType.PAYMENT -&gt; require(command.signers.containsAll(involvedParties)) { "all involved parties have signed" }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val exitCommand = tx.commands.select&lt;Commands.Exit&lt;P&gt;&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount = inputs.sumObligationsOrNull&lt;P&gt;() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount: Amount&lt;Issued&lt;Terms&lt;P&gt;&gt;&gt; = inputs.sumObligationsOrNull() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val involvedParties: Set&lt;PublicKey&gt; = groupInputs.map { it.beneficiary.owningKey }.union(groupInputs.map { it.obligor.owningKey }).toSet()</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation${ val template = key.template // Create two maps of balances from obligors to beneficiaries, one for input states, the other for output states. val inputBalances = extractAmountsDue(template, groupInputs) val outputBalances = extractAmountsDue(template, groupOutputs) // Sum the columns of the matrices. This will yield the net amount payable to/from each party to/from all other participants. // The two summaries must match, reflecting that the amounts owed match on both input and output. requireThat { "all input states use the same template" using (groupInputs.all { it.template == template }) "all output states use the same template" using (groupOutputs.all { it.template == template }) "amounts owed on input and output must match" using (sumAmountsDue(inputBalances) == sumAmountsDue (outputBalances)) } // TODO: Handle proxies nominated by parties, i.e. a central clearing service val involvedParties: Set&lt;PublicKey&gt; = groupInputs.map { it.beneficiary.owningKey }.union(groupInputs.map { it.obligor.owningKey }).toSet() when (command.value.type) { // For close-out netting, allow any involved party to sign NetType.CLOSE_OUT -&gt; require(command.signers.intersect(involvedParties).isNotEmpty()) { "any involved party has signed" } // Require signatures from all parties (this constraint can be changed for other contracts, and is used as a // placeholder while exact requirements are established), or fail the transaction. NetType.PAYMENT -&gt; require(command.signers.containsAll(involvedParties)) { "all involved parties have signed" } } }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation.Commands$SetLifecycle : CommandData</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:Obligation.kt$infix fun &lt;T : Any&gt; Obligation.State&lt;T&gt;.between(parties: Pair&lt;AbstractParty, AbstractParty&gt;)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract fun extractCommands(commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;): Collection&lt;CommandWithParties&lt;C&gt;&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$val changeOwner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic @Deprecated("Replaced with generateExit() which takes in a party to pay change to") fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateExit(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData): Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateExit(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData): Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$amount: Amount&lt;T&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$generateMoveCommand: () -&gt; CommandData</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$log.trace { "Gathered coins: requested $amount, available $gatheredAmount, change: ${gatheredAmount - amount}" }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$remainingFromEachIssuer[remainingFromEachIssuer.lastIndex] = Pair(token, Amount(delta, token))</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$return generateExit(tx, amountIssued, assetStates, owner, deriveState, generateMoveCommand, generateExitCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$return generateSpend(tx, listOf(PartyAndAmount(to, amount)), acceptableStates, payChangeTo, deriveState, generateMoveCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$val owner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // Discussion // // This code is analogous to the Wallet.send() set of methods in bitcoinj, and has the same general outline. // // First we must select a set of asset states (which for convenience we will call 'coins' here, as in bitcoinj). // The input states can be considered our "vault", and may consist of different products, and with different // issuers and deposits. // // Coin selection is a complex problem all by itself and many different approaches can be used. It is easily // possible for different actors to use different algorithms and approaches that, for example, compete on // privacy vs efficiency (number of states created). Some spends may be artificial just for the purposes of // obfuscation and so on. // // Having selected input states of the correct asset, we must craft output states for the amount we're sending and // the "change", which goes back to us. The change is required to make the amounts balance. We may need more // than one change output in order to avoid merging assets from different deposits. The point of this design // is to ensure that ledger entries are immutable and globally identifiable. // // Finally, we add the states to the provided partial transaction. // TODO: We should be prepared to produce multiple transactions spending inputs from // different notaries, or at least group states by notary and take the set with the // highest total value. // TODO: Check that re-running this on the same transaction multiple times does the right thing. // The notary may be associated with a locked state only. tx.notary = acceptableStates.firstOrNull()?.state?.notary // Calculate the total amount we're sending (they must be all of a compatible token). val totalSendAmount = payments.map { it.amount }.sumOrThrow() // Select a subset of the available states we were given that sums up to &gt;= totalSendAmount. val (gathered, gatheredAmount) = gatherCoins(acceptableStates, totalSendAmount) check(gatheredAmount &gt;= totalSendAmount) val keysUsed = gathered.map { it.state.data.owner.owningKey } // Now calculate the output states. This is complicated by the fact that a single payment may require // multiple output states, due to the need to keep states separated by issuer. We start by figuring out // how much we've gathered for each issuer: this map will keep track of how much we've used from each // as we work our way through the payments. val statesGroupedByIssuer = gathered.groupBy { it.state.data.amount.token } val remainingFromEachIssuer = statesGroupedByIssuer .mapValues { it.value.map { it.state.data.amount }.sumOrThrow() }.toList().toMutableList() val outputStates = mutableListOf&lt;TransactionState&lt;S&gt;&gt;() for ((party, paymentAmount) in payments) { var remainingToPay = paymentAmount.quantity while (remainingToPay &gt; 0) { val (token, remainingFromCurrentIssuer) = remainingFromEachIssuer.last() val templateState = statesGroupedByIssuer[token]!!.first().state val delta = remainingFromCurrentIssuer.quantity - remainingToPay when { delta &gt; 0 -&gt; { // The states from the current issuer more than covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer[remainingFromEachIssuer.lastIndex] = Pair(token, Amount(delta, token)) remainingToPay = 0 } delta == 0L -&gt; { // The states from the current issuer exactly covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay = 0 } delta &lt; 0 -&gt; { // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity } } } } // Whatever values we have left over for each issuer must become change outputs. for ((token, amount) in remainingFromEachIssuer) { val templateState = statesGroupedByIssuer[token]!!.first().state outputStates += deriveState(templateState, amount, payChangeTo) } for (state in gathered) tx.addInputState(state) for (state in outputStates) tx.addOutputState(state) // What if we already have a move command with the right keys? Filter it out here or in platform code? tx.addCommand(generateMoveCommand(), keysUsed) return Pair(tx, keysUsed) }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity }</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligations(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrNull(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrZero(issuanceDef: Issued&lt;Obligation.Terms&lt;P&gt;&gt;): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCash(): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashBy(owner: AbstractParty): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashOrNull(): Amount&lt;Issued&lt;Currency&gt;&gt;?</ID>
    <ID>NestedBlockDepth:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>NewLineAtEndOfFile:CommercialPaper.kt$net.corda.finance.contracts.CommercialPaper.kt</ID>
    <ID>WildcardImport:Cash.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:CommercialPaper.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:OnLedgerAsset.kt$import net.corda.core.contracts.*</ID>
  </Whitelist>
</SmellBaseline>
