<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$FINALISING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$SIGNING_TX : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$SENDING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary.Companion$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$AWAITING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$VERIFYING_AND_SIGNING : Step</ID>
    <ID>ComplexMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: future implementation to retrieve contract states from a Vault BLOB store</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: make parameters configurable when we get CorDapp configuration.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: revisit the back off strategy for contended spending.</ID>
    <ID>ForbiddenComment:CashPaymentFlow.kt$CashPaymentFlow$// TODO: Have some way of restricting this to states the caller controls</ID>
    <ID>ForbiddenComment:ObligationUtils.kt$ObligationUtils$// TODO: A much better (but more complex) solution would be to have two iterators, one for obligations,</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Also, the term Deal is used here where we might prefer Agreement.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Make this flow more generic.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: The subclasses should probably be broken out into individual flows rather than making this an ever expanding collection of subclasses.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow$// TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer.RECORDING$// TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733.</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Double, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Int, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Long, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>LongMethod:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$// This is one MSSQL implementation of the query to select just enough cash states to meet the desired amount. // We select the cash states with smaller amounts first so that as the result, we minimize the numbers of // unspent cash states remaining in the vault. // // If there is not enough cash, the query will return an empty resultset, which should signal to the caller // of an exception, since the desired amount is assumed to always &gt; 0. // NOTE: The other two implementations, H2 and PostgresSQL, behave differently in this case - they return // all in the vault instead of nothing. That seems to give the caller an extra burden to verify total returned // &gt;= amount. // In addition, extra data fetched results in unnecessary I/O. // Nevertheless, if so desired, we can achieve the same by changing the last FROM clause to // FROM CTE LEFT JOIN Boundary AS B ON 1 = 1 // WHERE B.seqNo IS NULL OR CTE.seqNo &lt;= B.seqNo // // Common Table Expression and Windowed functions help make the query more readable. // Query plan does index scan on pennies_idx, which may be unavoidable due to the nature of the query. override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet())</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, acceptableContract: SecureHash, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, dueBefore: Instant, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, issuanceDef: Obligation.Terms&lt;P&gt;, pennies: Long, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$3</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$4</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$5</ID>
    <ID>MagicNumber:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$3</ID>
    <ID>MagicNumber:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$60</ID>
    <ID>MagicNumber:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$30</ID>
    <ID>MatchingDeclarationName:FinanceWorkflowsUtils.kt$net.corda.finance.workflows.utils.FinanceWorkflowsUtils.kt</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$AbstractCashFlow$@Suspendable protected</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$CashException : FlowException</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ @Suspendable fun unconsumedCashStatesForSpending(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet()): List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ protected abstract fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection for $amount retrieved ${stateAndRefs.count()} states totalling $totalPennies pennies: $stateAndRefs")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection requested $amount but retrieved $totalPennies pennies with state refs: ${stateAndRefs.map { it.ref }}")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$onlyFromIssuerParties: Set&lt;AbstractParty&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$private</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$val durationMillis = (minOf(retrySleep.shl(retryCount), retryCap / 2) * (1.0 + Math.random())).toInt()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$"\nPlease specify an implementation in META-INF/services/${AbstractCashSelection::class.qualifiedName}."</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$val cashSelectionAlgos = ServiceLoader.load(AbstractCashSelection::class.java, this::class.java.classLoader).toList()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion${ instance.set(cashSelectionAlgo) cashSelectionAlgo }</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount)</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow${ progressTracker.currentStep = GENERATING_TX val builder = TransactionBuilder(notary = null) val issuer = ourIdentity.ref(issuerRef) val exitStates = AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference)) val signers = try { val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount) Cash().generateExit( builder, amount.issuedBy(issuer), exitStates, changeOwner) } catch (e: InsufficientBalanceException) { throw CashException("Exiting more cash than exists", e) } // Work out who the owners of the burnt states were (specify page size so we don't silently drop any if &gt; DEFAULT_PAGE_SIZE) val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states val participantSessions = inputStates .asSequence() .mapNotNull { serviceHub.identityService.wellKnownPartyFromAnonymous(it.state.data.owner) } .filterNot(serviceHub.myInfo::isLegalIdentity) .distinct() .map(::initiateFlow) .toList() // Sign transaction progressTracker.currentStep = SIGNING_TX val tx = serviceHub.signInitialTransaction(builder, signers) // Commit the transaction progressTracker.currentStep = FINALISING_TX val notarised = finaliseTx(tx, participantSessions, "Unable to notarise exit") return Result(notarised, null) }</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$constructor(request: IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$/** A straightforward constructor that constructs spends using cash states of any issuer. */ constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean) : this(amount, recipient, anonymous, tracker())</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean, notary: Party) : this(amount, recipient, anonymous, tracker(), notary = notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(request: PaymentRequest) : this(request.amount, request.recipient, request.anonymous, tracker(), request.issuerConstraint, request.notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$override</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl${ connection.createStatement().use { it.execute("CALL SET(@t, CAST(0 AS BIGINT));") } // state_status = 0 -&gt; UNCONSUMED. // is_relevant = 0 -&gt; RELEVANT. val selectJoin = """ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id FROM vault_states AS vs, contract_cash_states AS ccs WHERE vs.transaction_id = ccs.transaction_id AND vs.output_index = ccs.output_index AND vs.state_status = 0 AND vs.relevancy_status = 0 AND ccs.ccy_code = ? and @t &lt; ? AND (vs.lock_id = ? OR vs.lock_id is null) """ + (if (notary != null) " AND vs.notary_name = ?" else "") + (if (onlyFromIssuerParties.isNotEmpty()) { val repeats = generateSequence { "?" }.take(onlyFromIssuerParties.size).joinToString(",") " AND ccs.issuer_key_hash IN ($repeats)" } else "") + (if (withIssuerRefs.isNotEmpty()) { val repeats = generateSequence { "?" }.take(withIssuerRefs.size).joinToString(",") " AND ccs.issuer_ref IN ($repeats)" } else "") // Use prepared statement for protection against SQL Injection (http://www.h2database.com/html/advanced.html#sql_injection) connection.prepareStatement(selectJoin).use { psSelectJoin -&gt; var pIndex = 0 psSelectJoin.setString(++pIndex, amount.token.currencyCode) psSelectJoin.setLong(++pIndex, amount.quantity) psSelectJoin.setString(++pIndex, lockId.toString()) if (notary != null) psSelectJoin.setString(++pIndex, notary.name.toString()) onlyFromIssuerParties.forEach { psSelectJoin.setString(++pIndex, it.owningKey.toStringShort()) } withIssuerRefs.forEach { psSelectJoin.setBytes(++pIndex, it.bytes) } log.debug { psSelectJoin.toString() } psSelectJoin.executeQuery().use { rs -&gt; return withResultSet(rs) } } }</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$ coalesce((SUM(ccs.pennies) OVER (PARTITION BY 1 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)), 0)</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$override</ID>
    <ID>MaxLineLength:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$override</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$@Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)"))</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$return generateSpend(services, tx, listOf(PartyAndAmount(to, amount)), services.myInfo.legalIdentitiesAndCerts.single(), onlyFromParties)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils${ fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt; { return txState.copy(data = txState.data.copy(amount = amt, owner = owner)) } // Retrieve unspent and unlocked cash states that meet our spending criteria. val totalAmount = payments.map { it.amount }.sumOrThrow() val cashSelection = AbstractCashSelection.getInstance { services.jdbcSession().metaData } val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId) val revocationEnabled = false // Revocation is currently unsupported // If anonymous is true, generate a new identity that change will be sent to for confidentiality purposes. This means that a // third party with a copy of the transaction (such as the notary) cannot identify who the change was // sent to val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party return OnLedgerAsset.generateSpend( tx, payments, acceptableCoins, changeIdentity, ::deriveState, Cash()::generateMoveCommand ) }</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @JvmStatic fun generateIssue(issuance: PartyAndReference, faceValue: Amount&lt;Issued&lt;Currency&gt;&gt;, maturityDate: Instant, notary: Party): TransactionBuilder</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @Throws(InsufficientBalanceException::class) @JvmStatic @Suspendable fun generateRedeem(tx: TransactionBuilder, paper: StateAndRef&lt;CommercialPaper.State&gt;, services: ServiceHub, ourIdentity: PartyAndCertificate)</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$CashUtils.generateSpend(services, tx, paper.state.data.faceValue.withoutIssuer(), ourIdentity, paper.state.data.owner)</ID>
    <ID>MaxLineLength:Currencies.kt$infix fun Amount&lt;Currency&gt;.issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$BusinessCalendar(stream.reader().readText().split(",").map { BusinessCalendar.parseDateFromString(it) }.toSortedSet())</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$val stream = UnknownCalendar::class.java.getResourceAsStream("/net/corda/finance/workflows/utils/${name}HolidayCalendar.txt") ?: throw UnknownCalendar(name)</ID>
    <ID>MaxLineLength:GetBalances.kt$CashSchemaV1.PersistentCashState::pennies</ID>
    <ID>MaxLineLength:GetBalances.kt$require(rows.otherResults[1] == currency.currencyCode){"Currency on rows returned by query does not match expected"}</ID>
    <ID>MaxLineLength:GetBalances.kt$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) } val sumCriteria = QueryCriteria.VaultCustomQueryCriteria(sum) val ccyIndex = builder { CashSchemaV1.PersistentCashState::currency.equal(currency.currencyCode) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). val ccyCriteria = QueryCriteria.VaultCustomQueryCriteria(ccyIndex, relevancyStatus = Vault.RelevancyStatus.RELEVANT) return sumCriteria.and(ccyCriteria) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). return QueryCriteria.VaultCustomQueryCriteria(sum, relevancyStatus = Vault.RelevancyStatus.RELEVANT) }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateCloseOutNetting(tx: TransactionBuilder, signer: AbstractParty, vararg inputs: StateAndRef&lt;Obligation.State&lt;P&gt;&gt;)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all states are in the normal lifecycle state " using (states.all { it.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$Obligation.State(Obligation.Lifecycle.NORMAL, obligor, issuanceDef, amount.quantity, beneficiary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$deriveState = { state, amount, owner -&gt; state.copy(data = state.data.withNewOwnerAndAmount(amount, owner)) }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$private</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$require(states.all { it.lifecycle == existingLifecycle }) { "initial lifecycle must be $existingLifecycle for all input states" }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$val changeOwner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils${ val states = statesAndRefs.map { it.state } val obligationIssuer = states.first().data.obligor val obligationOwner = states.first().data.beneficiary requireThat { "all fungible asset states use the same notary" using (assetStatesAndRefs.all { it.state.notary == notary }) "all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL }) "all obligation states use the same notary" using (statesAndRefs.all { it.state.notary == notary }) "all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer }) "all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner }) } // TODO: A much better (but more complex) solution would be to have two iterators, one for obligations, // one for the assets, and step through each in a semi-synced manner. For now however we just bundle all the states // on each side together val issuanceDef = getIssuanceDefinitionOrThrow(statesAndRefs.map { it.state.data }) val template: Obligation.Terms&lt;P&gt; = issuanceDef.product val obligationTotal: Amount&lt;P&gt; = Amount(states.map { it.data }.sumObligations&lt;P&gt;().quantity, template.product) var obligationRemaining: Amount&lt;P&gt; = obligationTotal val assetSigners = HashSet&lt;AbstractParty&gt;() statesAndRefs.forEach { tx.addInputState(it) } // Move the assets to the new beneficiary assetStatesAndRefs.forEach { ref -&gt; if (obligationRemaining.quantity &gt; 0L) { tx.addInputState(ref) val assetState = ref.state.data val amount = Amount(assetState.amount.quantity, assetState.amount.token.product) obligationRemaining -= if (obligationRemaining &gt;= amount) { tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary) amount } else { val change = Amount(obligationRemaining.quantity, assetState.amount.token) // Split the state in two, sending the change back to the previous beneficiary tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary) tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary) Amount(0L, obligationRemaining.token) } assetSigners.add(assetState.owner) } } // If we haven't cleared the full obligation, add the remainder as an output if (obligationRemaining.quantity &gt; 0L) { tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary) } else { // Destroy all of the states } // Add the asset move command and obligation settle tx.addCommand(moveCommand, assetSigners.map { it.owningKey }) tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey) }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$override</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$return Triple(ptx, arrayListOf(deal.participants.single { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) }.owningKey), emptyList())</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Handshake$@CordaSerializable data</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable protected abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownMe == ourIdentity){"Well known party for handshake identity ${it.secondaryIdentity} does not match ourIdentity"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownOtherParty == otherSideSession.counterparty){"Well known party for handshake identity ${it.primaryIdentity} does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$serviceHub.signInitialTransaction(utx, additionalSigningPubKeys).withAdditionalSignatures(additionalSignatures)</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val ptxSignedByOtherSide = ptx + subFlow(CollectSignatureFlow(ptx, otherSideSession, otherSideSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val sessionsForOtherSigners = excludeNotary(groupPublicKeysByWellKnownParty(serviceHub, ptxSignedByOtherSide.getMissingSigners()), ptxSignedByOtherSide).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val stx = subFlow(CollectSignaturesFlow(ptxSignedByOtherSide, sessionsForOtherSigners, additionalSigningPubKeys))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow${ // TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this // and [AbstractStateReplacementFlow]. class UnacceptablePriceException(givenPrice: Amount&lt;Currency&gt;) : FlowException("Unacceptable price: $givenPrice") class AssetMismatchException(val expectedTypeName: String, val typeName: String) : FlowException() { override fun toString() = "The submitted asset didn't match the expected type: $expectedTypeName vs $typeName" } /** * This object is serialised to the network and is the first flow message the seller sends to the buyer. * * @param payToIdentity anonymous identity of the seller, for payment to be sent to. */ @CordaSerializable data class SellerTradeInfo( val price: Amount&lt;Currency&gt;, val payToIdentity: PartyAndCertificate ) open class Seller(private val otherSideSession: FlowSession, private val assetToSell: StateAndRef&lt;OwnableState&gt;, private val price: Amount&lt;Currency&gt;, private val myParty: PartyAndCertificate, // TODO Left because in tests it's used to pass anonymous party. override val progressTracker: ProgressTracker = Seller.tracker()) : FlowLogic&lt;SignedTransaction&gt;() { companion object { object AWAITING_PROPOSAL : ProgressTracker.Step("Awaiting transaction proposal") // DOCSTART 3 object VERIFYING_AND_SIGNING : ProgressTracker.Step("Verifying and signing transaction proposal") { override fun childProgressTracker() = SignTransactionFlow.tracker() } // DOCEND 3 fun tracker() = ProgressTracker(AWAITING_PROPOSAL, VERIFYING_AND_SIGNING) } // DOCSTART 4 @Suspendable override fun call(): SignedTransaction { progressTracker.currentStep = AWAITING_PROPOSAL // Make the first message we'll send to kick off the flow. val hello = SellerTradeInfo(price, myParty) // What we get back from the other side is a transaction that *might* be valid and acceptable to us, // but we must check it out thoroughly before we sign! // SendTransactionFlow allows seller to access our data to resolve the transaction. subFlow(SendStateAndRefFlow(otherSideSession, listOf(assetToSell))) otherSideSession.send(hello) // Verify and sign the transaction. progressTracker.currentStep = VERIFYING_AND_SIGNING // DOCSTART 07 // Sync identities to ensure we know all of the identities involved in the transaction we're about to // be asked to sign subFlow(IdentitySyncFlow.Receive(otherSideSession)) // DOCEND 07 // DOCSTART 5 val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } } val txId = subFlow(signTransactionFlow).id // DOCEND 5 return subFlow(ReceiveFinalityFlow(otherSideSession, expectedTxId = txId)) } // DOCEND 4 // Following comment moved here so that it doesn't appear in the docsite: // There are all sorts of funny games a malicious secondary might play with it sends maybeSTX, // we should fix them: // // - This tx may attempt to send some assets we aren't intending to sell to the secondary, if // we're reusing keys! So don't reuse keys! // - This tx may include output states that impose odd conditions on the movement of the cash, // once we implement state pairing. // // but the goal of this code is not to be fully secure (yet), but rather, just to find good ways to // express flow state machines on top of the messaging layer. } open class Buyer(private val sellerSession: FlowSession, private val notary: Party, private val acceptablePrice: Amount&lt;Currency&gt;, private val typeToBuy: Class&lt;out OwnableState&gt;, private val anonymous: Boolean) : FlowLogic&lt;SignedTransaction&gt;() { constructor(otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt;) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true) // DOCSTART 2 object RECEIVING : ProgressTracker.Step("Waiting for seller trading info") object VERIFYING : ProgressTracker.Step("Verifying seller assets") object SIGNING : ProgressTracker.Step("Generating and signing transaction proposal") object COLLECTING_SIGNATURES : ProgressTracker.Step("Collecting signatures from other parties") { override fun childProgressTracker() = CollectSignaturesFlow.tracker() } object RECORDING : ProgressTracker.Step("Recording completed transaction") { // TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733. // override fun childProgressTracker() = FinalityFlow.tracker() } override val progressTracker = ProgressTracker(RECEIVING, VERIFYING, SIGNING, COLLECTING_SIGNATURES, RECORDING) // DOCEND 2 // DOCSTART 1 @Suspendable override fun call(): SignedTransaction { // Wait for a trade request to come in from the other party. progressTracker.currentStep = RECEIVING val (assetForSale, tradeRequest) = receiveAndValidateTradeRequest() // Create the identity we'll be paying to, and send the counterparty proof we own the identity val buyerAnonymousIdentity = if (anonymous) serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false) else ourIdentityAndCert // Put together a proposed transaction that performs the trade, and sign it. progressTracker.currentStep = SIGNING val (ptx, cashSigningPubKeys) = assembleSharedTX(assetForSale, tradeRequest, buyerAnonymousIdentity) // DOCSTART 6 // Now sign the transaction with whatever keys we need to move the cash. val partSignedTx = serviceHub.signInitialTransaction(ptx, cashSigningPubKeys) // Sync up confidential identities in the transaction with our counterparty subFlow(IdentitySyncFlow.Send(sellerSession, ptx.toWireTransaction(serviceHub))) // Send the signed transaction to the seller, who must then sign it themselves and commit // it to the ledger by sending it to the notary. progressTracker.currentStep = COLLECTING_SIGNATURES val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey)) val twiceSignedTx = partSignedTx + sellerSignature // DOCEND 6 // Notarise and record the transaction. progressTracker.currentStep = RECORDING return subFlow(FinalityFlow(twiceSignedTx, sellerSession)) } @Suspendable private fun receiveAndValidateTradeRequest(): Pair&lt;StateAndRef&lt;OwnableState&gt;, SellerTradeInfo&gt; { val assetForSale = subFlow(ReceiveStateAndRefFlow&lt;OwnableState&gt;(sellerSession)).single() return assetForSale to sellerSession.receive&lt;SellerTradeInfo&gt;().unwrap { progressTracker.currentStep = VERIFYING // What is the seller trying to sell us? val asset = assetForSale.state.data val assetTypeName = asset.javaClass.name // The asset must either be owned by the well known identity of the counterparty, or we must be able to // prove the owner is a confidential identity of the counterparty. val assetForSaleIdentity = serviceHub.identityService.wellKnownPartyFromAnonymous(asset.owner) require(assetForSaleIdentity == sellerSession.counterparty){"Well known identity lookup returned identity that does not match counterparty"} // Register the identity we're about to send payment to. This shouldn't be the same as the asset owner // identity, so that anonymity is enforced. val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" } if (it.price &gt; acceptablePrice) throw UnacceptablePriceException(it.price) if (!typeToBuy.isInstance(asset)) throw AssetMismatchException(typeToBuy.name, assetTypeName) it } } @Suspendable private fun assembleSharedTX(assetForSale: StateAndRef&lt;OwnableState&gt;, tradeRequest: SellerTradeInfo, buyerAnonymousIdentity: PartyAndCertificate): SharedTx { val ptx = TransactionBuilder(notary) // Add input and output states for the movement of cash, by using the Cash contract to generate the states val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party) // Add inputs/outputs/a command for the movement of the asset. tx.addInputState(assetForSale) val (command, state) = assetForSale.state.data.withNewOwner(buyerAnonymousIdentity.party) tx.addOutputState(state, assetForSale.state.contract, assetForSale.state.notary) tx.addCommand(command, assetForSale.state.data.owner.owningKey) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. val currentTime = serviceHub.clock.instant() tx.setTimeWindow(currentTime, 30.seconds) return SharedTx(tx, cashSigningPubKeys) } // DOCEND 1 data class SharedTx(val tx: TransactionBuilder, val cashSigningPubKeys: List&lt;PublicKey&gt;) } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$@Suspendable private</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$constructor(otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt;) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(assetForSaleIdentity == sellerSession.counterparty){"Well known identity lookup returned identity that does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$override val progressTracker: ProgressTracker = Seller.tracker()</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$private val myParty: PartyAndCertificate</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.&lt;no name provided&gt;$val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data }</ID>
    <ID>NewLineAtEndOfFile:AbstractCashFlow.kt$net.corda.finance.flows.AbstractCashFlow.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionH2Impl.kt$net.corda.finance.workflows.asset.selection.CashSelectionH2Impl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionSQLServerImpl.kt$net.corda.finance.workflows.asset.selection.CashSelectionSQLServerImpl.kt</ID>
    <ID>NewLineAtEndOfFile:ObligationUtils.kt$net.corda.finance.workflows.asset.ObligationUtils.kt</ID>
    <ID>SpreadOperator:ObligationUtils.kt$ObligationUtils$(*inputs)</ID>
    <ID>TooManyFunctions:Currencies.kt$net.corda.finance.Currencies.kt</ID>
    <ID>WildcardImport:AbstractCashFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractCashSelection.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CashExitFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashPaymentFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObligationUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyDealFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.flows.*</ID>
  </Whitelist>
</SmellBaseline>
