<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ComplexCondition:InternalUtils.kt$it.type == this &amp;&amp; it.isPublic &amp;&amp; it.isStatic &amp;&amp; it.isFinal</ID>
    <ID>ComplexCondition:WireTransaction.kt$WireTransaction$notary != null &amp;&amp; (inputs.isNotEmpty() || references.isNotEmpty() || timeWindow != null)</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>ComplexMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>ComplexMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:MerkleTransaction.kt$FilteredTransaction.Companion$ private fun filterWithFun(wtx: WireTransaction, filtering: Predicate&lt;Any&gt;): List&lt;FilteredComponentGroup&gt;</ID>
    <ID>ComplexMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>ComplexMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ComplexMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>ConstructorParameterNaming:ByteArrays.kt$ByteSequence$private val _bytes: ByteArray</ID>
    <ID>ConstructorParameterNaming:CommonSchema.kt$CommonSchemaV1.LinearState$_participants: Set&lt;AbstractParty&gt;</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaException$private var _cause: Throwable? = null</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaException$private var _message: String? = null</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaRuntimeException$private var _cause: Throwable?</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaRuntimeException$private var _message: String?</ID>
    <ID>EmptyFunctionBlock:Utils.kt$&lt;no name provided&gt;${}</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$DONE : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$STARTING : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$UNSTARTED : Step</ID>
    <ID>ForbiddenComment:AbstractAttachment.kt$AbstractAttachment$// TODO: read file size information from metadata instead of loading the data.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: This step should not be necessary, as signatures are re-checked in verifyRequiredSignatures.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: use keys from the keyManagementService instead</ID>
    <ID>ForbiddenComment:CertRole.kt$CertRole$// TODO: Link to the specification once it has a permanent URL</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow$// TODO: AbstractStateReplacementFlow needs updating to use this flow.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow.Companion$// TODO: Make the progress tracker adapt to the number of counterparties to collect from.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$SignTransactionFlow$// TODO: We should have a faster way of verifying we own a single key</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey$// TODO: replace with the more extensive, but slower, checkValidity() test.</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.Companion$// TODO: node.encoded.sequence() might be expensive, consider a faster deterministic compareTo implementation</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.NodeAndWeight$// TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal.</ID>
    <ID>ForbiddenComment:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: check transaction size is within limits</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: copy across encumbrances when performing contract upgrades</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: exclude encumbrance states from this check</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: relax this constraint once upgrading encumbered states is supported.</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: if there are encumbrance states in the inputs, just copy them across without modifying</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: re-map encumbrance pointers</ID>
    <ID>ForbiddenComment:Cordapp.kt$Cordapp.Info.ContractAndWorkflow$// TODO: future work in Gradle cordapp plugins to enforce separation of Contract and Workflow classes into separate jars</ID>
    <ID>ForbiddenComment:CordappImpl.kt$CordappImpl$// TODO: Also add [SchedulableFlow] as a Cordapp class</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change the val name to a more descriptive one as it's now confusing and looks like a Key type.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change val name to SPHINCS256_SHA512. This will break backwards compatibility.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: perform all cryptographic operations via Crypto.</ID>
    <ID>ForbiddenComment:CryptoUtils.kt$// TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`.</ID>
    <ID>ForbiddenComment:DigitalSignatureWithCert.kt$// TODO: Rename this to DigitalSignature.WithCert once we're happy for it to be public API. The methods will need documentation</ID>
    <ID>ForbiddenComment:EncodingUtils.kt$// TODO: follow the crypto-conditions ASN.1 spec, some changes are needed to be compatible with the condition</ID>
    <ID>ForbiddenComment:FetchDataFlow.kt$FetchDataFlow$// TODO: Support "large message" response streaming so response sizes are not limited by RAM.</ID>
    <ID>ForbiddenComment:FlowIORequest.kt$FlowIORequest.ForceCheckpoint$// TODO: consider using an empty FlowAsyncOperation instead</ID>
    <ID>ForbiddenComment:FlowLogicRef.kt$FlowLogicRef$// TODO: align this with the existing [FlowRef] in the bank-side API (probably replace some of the API classes)</ID>
    <ID>ForbiddenComment:IdempotentFlow.kt$TimedFlow$// TODO: allow specifying retry settings per flow</ID>
    <ID>ForbiddenComment:IdentityService.kt$IdentityService$// TODO: This should be done via the network map cache, which is the authoritative source of well known identities</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future.</ID>
    <ID>ForbiddenComment:LegalNameValidator.kt$LegalNameValidator.Rule.Companion$// TODO: Implement confusable character detection if we add more scripts.</ID>
    <ID>ForbiddenComment:NodeInfoConstants.kt$// TODO: Add to Corda node.conf to allow customisation</ID>
    <ID>ForbiddenComment:NotaryChangeFlow.kt$NotaryChangeFlow$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:NotaryError.kt$StateConsumptionDetails$// TODO: include notary timestamp?</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: This is not required any more once our AMQP serialization supports turning off object referencing.</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: [CORDA-2274] Perform full transaction verification once verification caching is enabled.</ID>
    <ID>ForbiddenComment:NotaryServiceFlow.kt$NotaryServiceFlow.Companion$// TODO: Determine an appropriate limit and also enforce in the network parameters and the transaction builder.</ID>
    <ID>ForbiddenComment:NotaryUtils.kt$// TODO: if requestSignature was generated over an old version of NotarisationRequest, we need to be able to</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: Expose the concept of errors.</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: It'd be helpful if this class was at least partly thread safe.</ID>
    <ID>ForbiddenComment:ProviderMap.kt$// TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider.</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$// TODO: This could be done in parallel with other fetches for extra speed.</ID>
    <ID>ForbiddenComment:SendTransactionFlow.kt$DataVendingFlow$// Security TODO: Check for abnormally large or malformed data requests</ID>
    <ID>ForbiddenComment:ServiceHub.kt$ServicesForResolution$// TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load</ID>
    <ID>ForbiddenComment:ServiceHubCoreInternal.kt$ServiceHubCoreInternal$// TODO: This should really be called ServiceHubInternal but that name is already taken by net.corda.node.services.api.ServiceHubInternal.</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We could probably optimise the below by</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We need a much better way of structuring this data.</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: allow non-blocking verification.</ID>
    <ID>ForbiddenComment:SinglePartyNotaryService.kt$SinglePartyNotaryService$// TODO: Log the request here. Benchmarking shows that logging is expensive and we might get better performance</ID>
    <ID>ForbiddenComment:Structures.kt$MoveCommand$// TODO: Replace Class here with a general contract constraints object</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$// TODO: Add support for making recursive resolution optional if it becomes an issue.</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$// TODO: Implement the contract sandbox loading of the contract attachments</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: we could avoid deserialising unrelated signers.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException$// TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$// TODO: add reference to documentation</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: prevent notary field from being set if there are no inputs and no time-window.</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: revisit once Deterministic JVM code updated</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allSteps(level: Int = 0): List&lt;Pair&lt;Int, Step&gt;&gt;</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _trackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>LongMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>LongParameterList:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T)</ID>
    <ID>LongParameterList:ContractAttachment.kt$ContractAttachment.Companion$(attachment: Attachment, contract: ContractClassName, additionalContracts: Set&lt;ContractClassName&gt; = emptySet(), uploader: String? = null, signerKeys: List&lt;PublicKey&gt; = emptyList(), version: Int = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters, upgradedContract: UpgradedContract&lt;ContractState, *&gt; )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = this.outputs, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; = this.commands, attachments: List&lt;Attachment&gt; = this.attachments, id: SecureHash = this.id, notary: Party? = this.notary, timeWindow: TimeWindow? = this.timeWindow, privacySalt: PrivacySalt = this.privacySalt, networkParameters: NetworkParameters? = this.networkParameters )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations )</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon )</ID>
    <ID>LongParameterList:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction.Companion$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, newNotary: Party, id: SecureHash, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters)</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition )</ID>
    <ID>LongParameterList:SerializationEnvironment.kt$SerializationEnvironment.Companion$( serializationFactory: SerializationFactory, p2pContext: SerializationContext, rpcServerContext: SerializationContext? = null, rpcClientContext: SerializationContext? = null, storageContext: SerializationContext? = null, checkpointContext: CheckpointSerializationContext? = null, checkpointSerializer: CheckpointSerializer? = null )</ID>
    <ID>LongParameterList:SinglePartyNotaryService.kt$SinglePartyNotaryService$( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:TransactionUtils.kt$(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?)</ID>
    <ID>LongParameterList:UniquenessProvider.kt$UniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow? = null, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime )</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime, relevancyStatus: Vault.RelevancyStatus? )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction$( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, resolveContractAttachment: (StateRef) -&gt; Attachment, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction.Companion$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?)</ID>
    <ID>MagicNumber:AttachmentsClassLoader.kt$AttachmentsClassLoader$4</ID>
    <ID>MagicNumber:ByteArrays.kt$10</ID>
    <ID>MagicNumber:ByteArrays.kt$16</ID>
    <ID>MagicNumber:ByteArrays.kt$4</ID>
    <ID>MagicNumber:CompositeSignature.kt$CompositeSignature$1024</ID>
    <ID>MagicNumber:CordaSecurityProvider.kt$CordaSecurityProvider$0.1</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$2048</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$256</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3072</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$4</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$5</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$6</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$8</ID>
    <ID>MagicNumber:CryptoUtils.kt$8</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F193</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F385</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F469</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4B0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4BB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4CE</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4DA</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4F0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F51C</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F537</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F60E</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F634</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F6AB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x200D</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2620</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x26A0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2705</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x27A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2B05</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0xFE0F</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic$300</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic.Companion$5</ID>
    <ID>MagicNumber:InternalUtils.kt$30</ID>
    <ID>MagicNumber:InternalUtils.kt$InputStreamAndHash.Companion$1024</ID>
    <ID>MagicNumber:JarSignatureCollector.kt$JarSignatureCollector$1024</ID>
    <ID>MagicNumber:NetworkHostAndPort.kt$NetworkHostAndPort$0xffff</ID>
    <ID>MagicNumber:NullKeys.kt$NullKeys$32</ID>
    <ID>MagicNumber:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$4</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.Companion$32</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.SHA256$32</ID>
    <ID>MagicNumber:Structures.kt$PrivacySalt$32</ID>
    <ID>MagicNumber:TargetVersionDependentRules.kt$StateContractValidationEnforcementRule$4</ID>
    <ID>MagicNumber:TransactionBuilder.kt$TransactionBuilder$4</ID>
    <ID>MagicNumber:TransactionUtils.kt$100</ID>
    <ID>MagicNumber:TransactionUtils.kt$4</ID>
    <ID>MagicNumber:TransactionVerifierServiceInternal.kt$Verifier$4</ID>
    <ID>MagicNumber:WireTransaction.kt$WireTransaction$4</ID>
    <ID>MatchingDeclarationName:ConfigException.kt$net.corda.core.cordapp.ConfigException.kt</ID>
    <ID>MatchingDeclarationName:ContractsDSL.kt$net.corda.core.contracts.ContractsDSL.kt</ID>
    <ID>MatchingDeclarationName:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>MatchingDeclarationName:NamedCache.kt$net.corda.core.internal.NamedCache.kt</ID>
    <ID>MatchingDeclarationName:NetworkParametersServiceInternal.kt$net.corda.core.internal.NetworkParametersServiceInternal.kt</ID>
    <ID>MatchingDeclarationName:PlatformSecureRandom.kt$net.corda.core.crypto.internal.PlatformSecureRandom.kt</ID>
    <ID>MatchingDeclarationName:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$// We whitelist sources of transaction JARs for now as a temporary state until the DJVM and other security sandboxes // have been integrated, at which point we'll be able to run untrusted code downloaded over the network and this mechanism // can be removed. Because we ARE downloading attachments over the P2P network in anticipation of this upgrade, we // track the source of each attachment in our store. TestDSL is used by LedgerDSLInterpreter when custom attachments // are added in unit test code. val TRUSTED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, TESTDSL_UPLOADER)</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$AbstractAttachment.Companion$ @DeleteForDJVM fun SerializeAsTokenContext.attachmentDataLoader(id: SecureHash): () -&gt; ByteArray</ID>
    <ID>MaxLineLength:AbstractParty.kt$AbstractParty$ override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Acceptor&lt;in T&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Instigator&lt;out S : ContractState, out T : ContractState, out M&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Proposal&lt;out M&gt;</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$ @Throws(StateReplacementException::class) protected abstract fun verifyProposal(stx: SignedTransaction, proposal: Proposal&lt;T&gt;)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$override val progressTracker: ProgressTracker = Acceptor.tracker()</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$require(myKey in requiredKeys) { "Party is not a participant for any of the input states of transaction ${stx.id}" }</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$@Suspendable private</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$return excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, originalState.state.data.participants)).map { initiateFlow(it.key) to it.value }</ID>
    <ID>MaxLineLength:Amount.kt$Amount$Companion</ID>
    <ID>MaxLineLength:Amount.kt$Amount$operator</ID>
    <ID>MaxLineLength:Amount.kt$Amount$require(other.displayTokenSize == displayTokenSize) { "Token size mismatch: ${other.displayTokenSize} vs $displayTokenSize" }</ID>
    <ID>MaxLineLength:Amount.kt$Amount${ // Amount represents a static balance of physical assets as managed by the distributed ledger and is not allowed // to become negative a rule further maintained by the Contract verify method. // N.B. If concepts such as an account overdraft are required this should be modelled separately via Obligations, // or similar second order smart contract concepts. require(quantity &gt;= 0) { "Negative amounts are not allowed: $quantity" } }</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any&gt; fromDecimal(displayQuantity: BigDecimal, token: T, rounding: RoundingMode = RoundingMode.FLOOR): Amount&lt;T&gt;</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic fun &lt;T : Any&gt; Iterable&lt;Amount&lt;T&gt;&gt;.sumOrZero(token: T)</ID>
    <ID>MaxLineLength:Amount.kt$Amount&lt;T : Any&gt; : Comparable</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ @Suppress("UNUSED") fun novate(centralParty: P): List&lt;AmountTransfer&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$destination: P = this.destination</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$result = 31 * result + (source.hashCode() xor destination.hashCode())</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any, P : Any&gt; fromDecimal(displayQuantityDelta: BigDecimal, token: T, source: P, destination: P, rounding: RoundingMode = RoundingMode.DOWN): AmountTransfer&lt;T, P&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer.Companion$destination: P</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer&lt;T : Any, P : Any&gt;</ID>
    <ID>MaxLineLength:Amount.kt$TokenizableAssetInfo$/** The nominal display unit size of a single token, potentially with trailing decimal display places if the scale parameter is non-zero. */ val displayTokenSize: BigDecimal</ID>
    <ID>MaxLineLength:AnonymousParty.kt$AnonymousParty : DestinationAbstractParty</ID>
    <ID>MaxLineLength:AppServiceHub.kt$AppServiceHub : ServiceHub</ID>
    <ID>MaxLineLength:Attachment.kt$Attachment$/** * The parties that have correctly signed the whole attachment. * Even though this returns a list of party objects, it is not required that these parties exist on the network, but rather they are a mapping from the signing key to the X.500 name. * * Note: Anyone can sign attachments, not only Corda parties. It's recommended to use [signerKeys]. */ @Deprecated("Use signerKeys. There is no requirement that attachment signers are Corda parties.") val signers: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AttachmentConstraint$ fun isSatisfiedBy(attachment: Attachment): Boolean</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint : AttachmentConstraint</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint$throw UnsupportedOperationException("Contracts cannot be satisfied by an AutomaticPlaceholderConstraint placeholder.")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$HashAttachmentConstraint$log.warn("Hash constraint check failed: $attachmentId does not match contract attachment JAR ${attachment.id} or contract attachment JAR is untrusted")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$NoConstraintPropagation</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$SignatureAttachmentConstraint$log.debug("Checking signature constraints: verifying $key in contract attachment signer keys: ${attachment.signerKeys}")</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ @Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)")) @Throws(FileAlreadyExistsException::class, IOException::class) fun importAttachment(jar: InputStream): AttachmentId</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ fun getLatestContractAttachments(contractClassName: String, minContractVersion: Int = DEFAULT_CORDAPP_VERSION): List&lt;AttachmentId&gt;</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$@Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)"))</ID>
    <ID>MaxLineLength:AttachmentWithContext.kt$AttachmentWithContext$"This AttachmentWithContext was not initialised properly. Please ensure all Corda contracts extending existing Corda contracts also implement the Contract base class."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader : URLClassLoader</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$(path == "meta-inf/services/net.corda.core.serialization.serializationwhitelist") -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$// This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash()</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$else -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id)</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$log</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$path.startsWith("meta-inf/services") -&gt; true</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$targetPlatformVersion &lt; 4 &amp;&amp; ignoreDirectories.any { path.startsWith(it) } -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ // Make some preliminary checks to ensure that we're not loading invalid attachments. // All attachments need to be valid JAR or ZIP files. for (attachment in attachments) { if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id) } // Until we have a sandbox to run untrusted code we need to make sure that any loaded class file was whitelisted by the node administrator. val untrusted = attachments .filter(::containsClasses) .filterNot(isAttachmentTrusted) .map(Attachment::id) if (untrusted.isNotEmpty()) { log.warn("Cannot verify transaction $sampleTxId as the following attachment IDs are untrusted: $untrusted." + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") throw TransactionVerificationException.UntrustedAttachmentsException(sampleTxId, untrusted) } // Enforce the no-overlap and package ownership rules. checkAttachments(attachments) }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ val entry = jar.nextJarEntry ?: break if (entry.isDirectory) continue // We already verified that paths are not strange/game playing when we inserted the attachment // into the storage service. So we don't need to repeat it here. // // We forbid files that differ only in case, or path separator to avoid issues for Windows/Mac developers where the // filesystem tries to be case insensitive. This may break developers who attempt to use ProGuard. // // Also convert to Unix path separators as all resource/class lookups will expect this. val path = entry.name.toLowerCase(Locale.US).replace('\\', '/') // Namespace ownership. We only check class files: resources are loaded relative to a JAR anyway. if (path.endsWith(".class")) { // Get the package name from the file name. Inner classes separate their names with $ not / // in file names so they are not a problem. val pkgName = path .dropLast(".class".length) .replace('/', '.') .split('.') .dropLast(1) .joinToString(".") for ((namespace, pubkey) in params.packageOwnership) { // Note that due to the toLowerCase() call above, we'll be comparing against a lowercased // version of the ownership claim. val ns = namespace.toLowerCase(Locale.US) // We need an additional . to avoid matching com.foo.Widget against com.foobar.Zap if (pkgName == ns || pkgName.startsWith("$ns.")) { if (pubkey !in signers) throw PackageOwnershipException(sampleTxId, attachment.id, path, pkgName) } } } // Some files don't need overlap checking because they don't affect the way the code runs. if (!shouldCheckForNoOverlap(path, targetPlatformVersion)) continue // This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash() = ByteArrayOutputStream().use { jar.copyTo(it) it.toByteArray() }.sha256() // If 2 entries are identical, it means the same file is present in both attachments, so that is ok. val currentHash = entryHash() val previousFileHash = classLoaderEntries[path] when { previousFileHash == null -&gt; { log.debug { "Adding new entry for $path" } classLoaderEntries[path] = currentHash } currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" } else -&gt; { log.debug { "Content hash differs for $path" } throw OverlappingAttachmentsException(sampleTxId, path) } } }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader.Companion$log.warn("The URLStreamHandlerFactory was already set in the JVM. Please be aware that this is not recommended.")</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T): T</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$private</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$val serializers = createInstancesOfClassesImplementing(transactionClassLoader, SerializationCustomSerializer::class.java)</ID>
    <ID>MaxLineLength:AutoAcceptable.kt$AutoAcceptable</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$else -&gt; throw throw IllegalArgumentException("We were expecting a ${ReceiveType::class.java.name} or WaitTimeUpdate but we instead got a ${unwrapped.javaClass.name} ($unwrapped)")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$is ReceiveType</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$logger.info("Counterparty [${session.counterparty}] is busy - TimedFlow $runId has been asked to wait for an additional ${unwrapped.waitTime} seconds for completion.")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow&lt;ResultType&gt; : FlowLogicTimedFlow</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outRef(index: Int): StateAndRef&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$/** * Helper property to return a list of [ContractState] objects, rather than the often less convenient [TransactionState] */ val outputStates: List&lt;ContractState&gt; get() = outputs.map { it.data }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$CoreTransaction$/** * Hash of the network parameters that were in force when the transaction was notarised. Null means, that the transaction * was created on older version of Corda (before 4), resolution will default to initial parameters. */ abstract val networkParametersHash: SecureHash?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$"Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]"</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$/** * Network parameters that were in force when this transaction was created. Resolved from the hash of network parameters on the corresponding * wire transaction. */ abstract val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$// Network parameters will never be null if the transaction is resolved from a CoreTransaction rather than constructed directly. networkParameters?.let { parameters -&gt; val notaryWhitelist = parameters.notaries.map { it.identity } check(notaryParty in notaryWhitelist) { "Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]" } }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$check(notaries.single() == notary) { "The specified notary must be the one specified by all inputs and input references" }</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ @Suppress("MemberVisibilityCanBePrivate") fun subSequence(offset: Int, size: Int): ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ fun slice(start: Int = 0, end: Int = size): ByteBuffer</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytes$/** * The bytes are always cloned so that this object becomes immutable. This has been done * to prevent tampering with entities such as [net.corda.core.crypto.SecureHash] and [net.corda.core.contracts.PrivacySalt], as well as * preserve the integrity of our hash constants [net.corda.core.crypto.SecureHash.zeroHash] and [net.corda.core.crypto.SecureHash.allOnesHash]. * * Cloning like this may become a performance issue, depending on whether or not the JIT * compiler is ever able to optimise away the clone. In which case we may need to revisit * this later. */ final override val bytes: ByteArray = bytes get() = field.clone()</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence : ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(offset &gt;= 0 &amp;&amp; offset &lt; bytes.size) { "Offset must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(size &gt;= 0 &amp;&amp; offset + size &lt;= bytes.size) { "Sub-sequence size must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole : ASN1Encodable</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole$enum</ID>
    <ID>MaxLineLength:CheckpointSerializationAPI.kt$CheckpointSerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:ClassGraphUtils.kt$ fun ClassGraph.pooledScan(): ScanResult</ID>
    <ID>MaxLineLength:ClassLoadingUtils.kt$ @StubOutForDJVM fun &lt;T: Any&gt; createInstancesOfClassesImplementing(classloader: ClassLoader, clazz: Class&lt;T&gt;): Set&lt;T&gt;</ID>
    <ID>MaxLineLength:ClientRpcSslOptions.kt$ClientRpcSslOptions</ID>
    <ID>MaxLineLength:ClientRpcSslOptions.kt$ClientRpcSslOptions$data</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignatureFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$else -&gt; throw IllegalArgumentException("Signatures can only be collected from Party or AnonymousParty, not $destination")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$override val progressTracker: ProgressTracker = CollectSignaturesFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$require(it.value.size == 1) { "There are multiple sessions initiated for party key ${it.key.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$val wellKnownParty = checkNotNull(keyToSigningParty[it]) { "Could not find a session or wellKnown party for key ${it.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow${ // setOfAllSessionKeys has already checked for valid destination types so we can safely cast to AnonoymousParty here. // This session was not initiated by a wellKnownParty so must directly exist in the unsigned. (it.destination as AnonymousParty).owningKey in unsigned }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow$override val progressTracker: ProgressTracker = SignTransactionFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow${ progressTracker.currentStep = RECEIVING // Receive transaction and resolve dependencies, check sufficient signatures is disabled as we don't have all signatures. val stx = subFlow(ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = false)) // Receive the signing key that the party requesting the signature expects us to sign with. Having this provided // means we only have to check we own that one key, rather than matching all keys in the transaction against all // keys we own. val signingKeys = otherSideSession.receive&lt;List&lt;PublicKey&gt;&gt;().unwrap { keys -&gt; // TODO: We should have a faster way of verifying we own a single key serviceHub.keyManagementService.filterMyKeys(keys) } progressTracker.currentStep = VERIFYING // Check that the Responder actually needs to sign. checkMySignaturesRequired(stx, signingKeys) // Check the signatures which have already been provided. Usually the Initiators and possibly an Oracle's. checkSignatures(stx) stx.tx.toLedgerTransaction(serviceHub).verify() // Perform some custom verification over the transaction. try { checkTransaction(stx) } catch (e: Exception) { if (e is IllegalStateException || e is IllegalArgumentException || e is AssertionError) throw FlowException(e) else throw e } // Sign and send back our signature to the Initiator. progressTracker.currentStep = SIGNING val mySignatures = signingKeys.map { key -&gt; serviceHub.createSignature(stx, key) } otherSideSession.send(mySignatures) // Return the additionally signed transaction. return stx + mySignatures }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$ fun isFulfilledBy(keysToCheck: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$return SubjectPublicKeyInfo(AlgorithmIdentifier(CordaObjectIdentifier.COMPOSITE_KEY), DERSequence(keyVector)).encoded</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$ fun build(threshold: Int? = null): PublicKey</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$require(threshold == null || threshold &gt; 0) { "Threshold must not be specified or its value must be greater than zero" }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder${ "Trying to build invalid CompositeKey, threshold value different than weight of single child node." }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder${ require(threshold == null || threshold == children.first().weight) { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." } // Returning the only child node which is [PublicKey] itself. We need to avoid single-key [CompositeKey] instances, // as there are scenarios where developers expected the underlying key and its composite versions to be equivalent. children.first().node }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.NodeAndWeight$if (weight == other.weight) // TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal. node.encoded.sequence().compareTo(other.node.encoded.sequence()) else weight.compareTo(other.weight)</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw InvalidKeyException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw SignatureException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature.Companion$@JvmStatic fun getService(provider: Provider)</ID>
    <ID>MaxLineLength:CompositeSignaturesWithKeys.kt$CompositeSignaturesWithKeys</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$ fun &lt;V, W&gt; firstOf(vararg futures: CordaFuture&lt;out V&gt;, handler: (CordaFuture&lt;out V&gt;) -&gt; W)</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$internal</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ internal fun ContractClassName.contractHasAutomaticConstraintPropagation(classLoader: ClassLoader? = null): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticHashConstraint || output is AutomaticHashConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$log.warnOnce("Found state ${state.contract} that is constrained by the insecure: AlwaysAcceptAttachmentConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$require(state.constraint::class in validConstraints) { "Found state ${state.contract} with an illegal constraint: ${state.constraint}" }</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$val Attachment.contractVersion: Version get() = if (this is ContractAttachment) version else CordappImpl.DEFAULT_CORDAPP_VERSION</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$when { // These branches should not happen, as this has been already checked. input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.") input is AutomaticHashConstraint || output is AutomaticHashConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.") // Transition to the same constraint. input == output -&gt; true // You can't transition from the AlwaysAcceptAttachmentConstraint to anything else, as it could hide something illegal. input is AlwaysAcceptAttachmentConstraint &amp;&amp; output !is AlwaysAcceptAttachmentConstraint -&gt; false // Nothing can be migrated from the HashConstraint except a HashConstraint with the same Hash. (This check is redundant, but added for clarity) input is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; input == output // Anything (except the AlwaysAcceptAttachmentConstraint) can be transformed to a HashAttachmentConstraint. input !is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; true // The SignatureAttachmentConstraint allows migration from a Signature constraint with the same key. // TODO - we don't support currently third party signers. When we do, the output key will have to be stronger then the input key. input is SignatureAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; input.key == output.key // HashAttachmentConstraint can be transformed to a SignatureAttachmentConstraint when hash constraint verification checking disabled. HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true // You can transition from the WhitelistConstraint to the SignatureConstraint only if all signers of the JAR are required to sign in the future. input is WhitelistedByZoneAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; attachment.signerKeys.isNotEmpty() &amp;&amp; output.key.keys.containsAll(attachment.signerKeys) else -&gt; false }</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment : Attachment</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$return "ContractAttachment(attachment=${attachment.id}, contracts='$allContracts', uploader='$uploader', signed='$isSigned', version='$version')"</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$uploader: String? = null</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow$Authorise : FlowLogic</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$( originalState: StateAndRef&lt;OldState&gt;, newContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt; )</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeFilteredTransaction : CoreTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractClassName: ContractClassName, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$@Deprecated("ContractUpgradeLedgerTransaction should not be created directly, use ContractUpgradeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$return "ContractUpgradeLedgerTransaction(inputs=$inputs, notary=$notary, legacyContractAttachment=$legacyContractAttachment, upgradedContractAttachment=$upgradedContractAttachment, id=$id, privacySalt=$privacySalt, sigs=$sigs, networkParameters=$networkParameters, upgradedContract=$upgradedContract, references=$references, legacyContractClassName='$legacyContractClassName', outputs=$outputs)"</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$return ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractAttachment, id, privacySalt, sigs, networkParameters, upgradedContract)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$val cordappLoader = services.cordappProvider::class.java.getMethod("getCordappLoader").invoke(services.cordappProvider)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ @CordaInternal internal fun resolveOutputComponent(services: ServicesForResolution, stateRef: StateRef, params: NetworkParameters): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun buildFilteredTransaction(): ContractUpgradeFilteredTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$PARAMETERS_HASH.ordinal to FilteredComponent(serializedComponents[PARAMETERS_HASH.ordinal], nonces[PARAMETERS_HASH.ordinal])</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$classLoader.loadClass(className).asSubclass(UpgradedContract::class.java).newInstance() as UpgradedContract&lt;ContractState, ContractState&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$private</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val binaryInput: SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt; = resolveStateRefBinaryComponent(inputs[stateRef.index], services)!!</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val legacyContractAttachmentId: SecureHash by lazy { serializedComponents[LEGACY_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val resolvedNetworkParameters = services.networkParametersService.lookup(hashToResolve) ?: throw TransactionResolutionException(id)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractAttachmentId: SecureHash by lazy { serializedComponents[UPGRADED_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractClassName: ContractClassName by lazy { serializedComponents[UPGRADED_CONTRACT.ordinal].deserialize&lt;ContractClassName&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractsDSL.kt$inline</ID>
    <ID>MaxLineLength:ContractsDSL.kt$mapNotNull { if (klass.isInstance(it.value)) uncheckedCast&lt;CommandWithParties&lt;CommandData&gt;, CommandWithParties&lt;C&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:CordaException.kt$CordaException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaException$private var _cause: Throwable? = null</ID>
    <ID>MaxLineLength:CordaException.kt$CordaRuntimeException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaRuntimeException$private var _cause: Throwable?</ID>
    <ID>MaxLineLength:CordaFuture.kt$CordaFuture&lt;V&gt; : Future</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;ELEMENT&gt; CordaFuture&lt;out ELEMENT&gt;.mapError(transform: (Throwable) -&gt; Throwable): CordaFuture&lt;ELEMENT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;RESULT&gt; CordaFuture&lt;out RESULT&gt;.doOnError(accept: (Throwable) -&gt; Unit): CordaFuture&lt;RESULT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W, X&gt; CordaFuture&lt;out V&gt;.thenMatch(success: (V) -&gt; W, failure: (Throwable) -&gt; X)</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W&gt; CordaFuture&lt;out V&gt;.flatMap(transform: (V) -&gt; CordaFuture&lt;out W&gt;): CordaFuture&lt;W&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$CordaFutureImpl$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$internal fun &lt;V&gt; Future&lt;V&gt;.get(timeout: Duration? = null): V</ID>
    <ID>MaxLineLength:CordaInternal.kt$CordaInternal</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultQueryByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultQueryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultTrackByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultTrackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. @RPCReturnsObservables fun networkParametersFeed(): DataFeed&lt;ParametersUpdateInfo?, ParametersUpdateInfo&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. fun acceptNewNetworkParameters(parametersHash: SecureHash)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @CordaInternal @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") @RPCReturnsObservables fun internalVerifiedTransactionsFeed(): DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalVerifiedTransactionsSnapshot(): List&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @RPCReturnsObservables fun stateMachineRecordedTransactionMappingFeed(): DataFeed&lt;List&lt;StateMachineTransactionMapping&gt;, StateMachineTransactionMapping&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun clearNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeInfoFromParty(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun notaryIdentities(): List&lt;Party&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun refreshNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun setFlowsDrainingModeEnabled(enabled: Boolean)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun terminate(drainPendingFlows: Boolean = false)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByCriteria(criteria: QueryCriteria, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByWithSorting(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByCriteria(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithSorting(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ParametersUpdateInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$progressTrackerStepAndUpdates: DataFeed&lt;String, String&gt;? = this.progressTrackerStepAndUpdates</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$return copy(id = id, flowLogicClassName = flowLogicClassName, initiator = initiator, progressTrackerStepAndUpdates = progressTrackerStepAndUpdates, invocationContext = invocationContext)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$inline</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$sorting: Sort = Sort(emptySet())</ID>
    <ID>MaxLineLength:CordaService.kt$CordaService</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toLedgerTransaction(services: ServicesForResolution, serializationContext: SerializationContext): LedgerTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toWireTransaction(services: ServicesForResolution, serializationContext: SerializationContext): WireTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ private fun owns(packageName: String, fullClassName: String): Boolean</ID>
    <ID>MaxLineLength:CordaUtils.kt$"$requiredMinPlatformVersion. The current zone is only enforcing a minimum platform version of "</ID>
    <ID>MaxLineLength:CordaUtils.kt$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:CordaUtils.kt$Character.isJavaIdentifierStart(token[0]) &amp;&amp; token.toCharArray().drop(1).all { Character.isJavaIdentifierPart(it) }</ID>
    <ID>MaxLineLength:CordaUtils.kt$private</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$/** * @param organisation name of the organisation. * @param locality locality of the organisation, typically nearest major city. * @param country country the organisation is in, as an ISO 3166-1 2-letter country code. */ constructor(organisation: String, locality: String, country: String) : this(null, null, organisation, locality, null, country)</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$require(locality.length &lt; MAX_LENGTH_LOCALITY) { "Locality attribute (L) must contain less then $MAX_LENGTH_LOCALITY characters." }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$state?.let { require(it.length &lt; MAX_LENGTH_STATE) { "State attribute (ST) must contain less then $MAX_LENGTH_STATE characters." } }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$this(commonName = commonName, organisationUnit = null, organisation = organisation, locality = locality, state = null, country = country)</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp$Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$ContractAndWorkflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$Workflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$override fun toString()</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Default$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$override fun toString()</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.Companion$@CordaInternal fun create(cordapp: Cordapp, attachmentId: SecureHash?, classLoader: ClassLoader, config: CordappConfig): CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun get(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getBoolean(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getDouble(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getFloat(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getInt(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getLong(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getNumber(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getString(path: String)</ID>
    <ID>MaxLineLength:CordappImpl.kt$CordappImpl$val classList = rpcFlows + initiatedFlows + services + serializationWhitelists.flatMap { it.whitelist } + notaryService</ID>
    <ID>MaxLineLength:CordappProvider.kt$CordappProvider$ fun getAppContext(): CordappContext</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$ @Synchronized @VisibleForTesting fun &lt;T&gt; withCordapp(minimumPlatformVersion: Int = 1, targetPlatformVersion: Int = PLATFORM_VERSION, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$CordappImpl.TEST_INSTANCE.copy(minimumPlatformVersion = minimumPlatformVersion, targetPlatformVersion = targetPlatformVersion)</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$Exception().stackTrace .mapNotNull { cordappClasses[it.className] } // in case there are multiple classes matched, we select the first one having a single CorDapp registered against it. .firstOrNull { it.size == 1 }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmOverloads @JvmStatic fun generateKeyPair(signatureScheme: SignatureScheme = DEFAULT_SIGNATURE_SCHEME): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doSign(privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic fun generateKeyPair(schemeCodeName: String): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(schemeCodeName: String, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePrivateKey(schemeCodeName: String, encodedKey: ByteArray): PrivateKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePublicKey(schemeCodeName: String, encodedKey: ByteArray): PublicKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(signatureScheme: SignatureScheme, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun findSignatureScheme(schemeCodeName: String): SignatureScheme</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun publicKeyOnCurve(signatureScheme: SignatureScheme, publicKey: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$// Check if a public key satisfies algorithm specs (for ECC: key should lie on the curve and not being point-at-infinity). private fun validatePublicKey(signatureScheme: SignatureScheme, key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$AlgorithmIdentifier(BCObjectIdentifiers.sphincs256_with_SHA512, DLSequence(arrayOf(ASN1Integer(0), SHA512_256)))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ECDSA_SECP256R1_SHA256, ECDSA_SECP256K1_SHA256 -&gt; deriveKeyPairECDSA(signatureScheme.algSpec as ECParameterSpec, privateKey, seed)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw InvalidKeyException("Key type ${privateKey.algorithm} is not supported for deterministic key derivation")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw UnsupportedOperationException("Although supported for signing, deterministic key derivation is " + "not currently implemented for ${signatureScheme.schemeCodeName}")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCECPublicKey -&gt; publicKey.parameters == signatureScheme.algSpec &amp;&amp; !publicKey.q.isInfinity &amp;&amp; publicKey.q.isValid</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPrivateKey, is BCSphincs256PrivateKey -&gt; true</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPublicKey -&gt; key.modulus.bitLength() &gt;= 2048</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is EdDSAPublicKey -&gt; publicKey.params == signatureScheme.algSpec &amp;&amp; !isEdDSAPointAtInfinity(publicKey) &amp;&amp; publicKey.a.isOnCurve</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$listOf(AlgorithmIdentifier(BCObjectIdentifiers.sphincs256, DLSequence(arrayOf(ASN1Integer(0), SHA512_256))))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$private</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$require(txId.sha256() in usedHashes) { "Transaction with id:$txId is not a leaf in the provided partial Merkle tree" }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$return publicKey.a.toP3() == (EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw InvalidKeySpecException("This private key cannot be decoded, please ensure it is PKCS8 encoded and that " + "it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw throw InvalidKeySpecException("This public key cannot be decoded, please ensure it is X509 encoded and " + "that it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val bytes = entropy.toByteArray().copyOf(params.curve.field.getb() / 8) // Need to pad the entropy to the valid seed length.</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val keyPairGenerator = KeyPairGenerator.getInstance(signatureScheme.algorithmName, providerMap[signatureScheme.providerName])</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signableData = SignableData(originalSignedHash(txId, transactionSignature.partialMerkleTree), transactionSignature.signatureMetadata)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signature = Instances.getSignatureInstance(signatureScheme.signatureName, providerMap[signatureScheme.providerName])</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ // Compute HMAC(privateKey, seed). val macBytes = deriveHMAC(privateKey, seed) // Get the first EC curve fieldSized-bytes from macBytes. // According to recommendations from the deterministic ECDSA rfc, see https://tools.ietf.org/html/rfc6979 // performing a simple modular reduction would induce biases that would be detrimental to security. // Thus, the result is not reduced modulo q and similarly to BIP32, EC curve fieldSized-bytes are utilised. val fieldSizeMacBytes = macBytes.copyOf(parameterSpec.curve.fieldSize / 8) // Calculate value d for private key. val deterministicD = BigInteger(1, fieldSizeMacBytes) // Key generation checks follow the BC logic found in // https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java // There is also an extra check to align with the BIP32 protocol, according to which // if deterministicD &gt;= order_of_the_curve the resulted key is invalid and we should proceed with another seed. // TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key. // Although our hashing approach seems reasonable, we should check if there are alternatives, // especially if we use counters as well. if (deterministicD &lt; ECConstants.TWO || WNafUtil.getNafWeight(deterministicD) &lt; parameterSpec.n.bitLength().ushr(2) || deterministicD &gt;= parameterSpec.n) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val privateKeySpec = ECPrivateKeySpec(deterministicD, parameterSpec) val privateKeyD = BCECPrivateKey(privateKey.algorithm, privateKeySpec, BouncyCastleProvider.CONFIGURATION) // Compute the public key by scalar multiplication. // Note that BIP32 uses masterKey + mac_derived_key as the final private key and it consequently // requires an extra point addition: master_public + mac_derived_public for the public part. // In our model, the mac_derived_output, deterministicD, is not currently added to the masterKey and it // it forms, by itself, the new private key, which in turn is used to compute the new public key. val pointQ = FixedPointCombMultiplier().multiply(parameterSpec.g, deterministicD) // This is unlikely to happen, but we should check for point at infinity. if (pointQ.isInfinity) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val publicKeySpec = ECPublicKeySpec(pointQ, parameterSpec) val publicKeyD = BCECPublicKey(privateKey.algorithm, publicKeySpec, BouncyCastleProvider.CONFIGURATION) return KeyPair(publicKeyD, privateKeyD) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ val sigKey: SignatureScheme = Crypto.findSignatureScheme(keyPair.private) val sigMetaData: SignatureScheme = Crypto.findSignatureScheme(signableData.signatureMetadata.schemeNumberID) // Special handling if the advertised SignatureScheme is CompositeKey. // TODO fix notaries that advertise [CompositeKey] in their signature Metadata. Currently, clustered notary nodes // mention Crypto.COMPOSITE_KEY in their SignatureMetadata, but they are actually signing with a leaf-key // (and if they refer to it as a Composite key, then we lose info about the actual type of their signing key). // In short, their metadata should be the leaf key-type, until we support CompositeKey signatures. require(sigKey == sigMetaData || sigMetaData == Crypto.COMPOSITE_KEY) { "Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}." } val signatureBytes = doSign(sigKey.schemeCodeName, keyPair.private, signableData.serialize().bytes) return TransactionSignature(signatureBytes, keyPair.public, signableData.signatureMetadata) }</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ // TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`. @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.verify(content: ByteArray, signature: DigitalSignature)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun newSecureRandom(): SecureRandom</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun secureRandomBytes(numOfBytes: Int): ByteArray</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM fun random63BitValue(): Long</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun KeyPair.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun PublicKey.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.isValid(content: ByteArray, signature: DigitalSignature): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun &lt;T : Any&gt; serializedHash(x: T): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun PublicKey.isFulfilledBy(otherKeys: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(nonce: SecureHash, opaqueBytes: OpaqueBytes): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(opaqueBytes: OpaqueBytes, privacySalt: PrivacySalt, componentGroupIndex: Int, internalIndex: Int): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun computeNonce(privacySalt: PrivacySalt, groupIndex: Int, internalIndex: Int)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$throw IllegalStateException("Verification of CompositeKey signatures currently not supported.")</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert : DigitalSignature</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert$val parameters = PKIXParameters(setOf(TrustAnchor(parentCertsChain.last(), null))).apply { isRevocationEnabled = false }</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$SignedDataWithCert&lt;T : Any&gt; : NamedByHash</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$net.corda.core.internal.DigitalSignatureWithCert.kt</ID>
    <ID>MaxLineLength:EncodingUtils.kt$ fun parsePublicKeyBase58(base58String: String): PublicKey</ID>
    <ID>MaxLineLength:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow$otherSide: FlowSession</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow${ // This can happen when another transaction will insert the same attachment during this transaction. // The outcome is the same (the attachment is imported), so we can ignore this exception. logger.debug { "Attachment ${attachment.id} already inserted." } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment.Token$override fun fromToken(context: SerializeAsTokenContext)</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$IllegalTransactionRequest : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$MissingNetworkParameters : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$if (stx == null) toFetch += txid else // Although the full object is loaded here, only return the id. This prevents the full set of objects already present from // being checkpointed every time a request is made to download an object the node does not yet have. fromDisk += txid</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" } // TODO: Support "large message" response streaming so response sizes are not limited by RAM. // We can then switch to requesting items in large batches to minimise the latency penalty. // This is blocked by bugs ARTEMIS-1278 and ARTEMIS-1279. For now we limit attachments and txns to 10mb each // and don't request items in batch, which is a performance loss, but works around the issue. We have // configured Artemis to not fragment messages up to 10mb so we can send 10mb messages without problems. // Above that, we start losing authentication data on the message fragments and take exceptions in the // network layer. val maybeItems = ArrayList&lt;W&gt;(toFetch.size) for (hash in toFetch) { // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } } // Check for a buggy/malicious peer answering with something that we didn't ask for. val downloaded = validateFetchResponse(UntrustworthyData(maybeItems), toFetch) logger.debug { "Fetched ${downloaded.size} elements from ${otherSideSession.counterparty.name}" } maybeWriteToDisk(downloaded) // Re-load items already present before the download procedure. This ensures these objects are not unnecessarily checkpointed. val loadedFromDisk = loadExpected(fromDisk) Result(loadedFromDisk, downloaded) }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow$otherSide: FlowSession</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchTransactionsFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"${session.counterparty} has finished prematurely and we're trying to send them the finalised transaction. "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"Do not provide flow sessions for the local node. FinalityFlow will record the notarised transaction locally."</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant of the transaction. Sessions to non-participants can * also be provided. */ @JvmOverloads constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, progressTracker: ProgressTracker = tracker() ) : this(transaction, emptyList(), progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant. * @param oldParticipants An **optional** collection of parties for participants who are still using the old API. * * You will only need to use this parameter if you have upgraded your CorDapp from the V3 FinalityFlow API but are required to provide * backwards compatibility with participants running V3 nodes. If you're writing a new CorDapp then this does not apply and this * parameter should be ignored. */ @Deprecated(DEPRECATION_MSG) constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, oldParticipants: Collection&lt;Party&gt;, progressTracker: ProgressTracker ) : this(transaction, oldParticipants, progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, extraRecipients: Set&lt;Party&gt;) : this(transaction, extraRecipients, tracker(), emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, progressTracker: ProgressTracker) : this(transaction, emptySet(), progressTracker, emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$if (notary != null) transaction.verifySignaturesExcept(notary.owningKey) else transaction.verifyRequiredSignatures()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$logger</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$require(it.isEmpty()) { "The following parties are specified both in flow sessions and in the oldParticipants list: $it" }</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$val commandDataTypes = transaction.tx.commands.asSequence().mapNotNull { it.value::class.qualifiedName }.distinct()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$"accept notarised transactions without first checking their relevancy. Instead, use one of the constructors "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$private const</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$private val statesToRecord: StatesToRecord = ONLY_RELEVANT</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$return subFlow(object : ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = true, statesToRecord = statesToRecord) { override fun checkBeforeRecording(stx: SignedTransaction) { require(expectedTxId == null || expectedTxId == stx.id) { "We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was" + "not recorded and nor its states sent to the vault." } } })</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow.&lt;no name provided&gt;$"We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was"</ID>
    <ID>MaxLineLength:FlowException.kt$FlowException : CordaExceptionIdentifiableException</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandle&lt;A&gt; : FlowHandle</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$// For API compatibility fun copy(id: StateMachineRunId, returnValue: CordaFuture&lt;A&gt;, progress: Observable&lt;String&gt;): FlowProgressHandleImpl&lt;A&gt;</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$override val stepsTreeFeed: DataFeed&lt;List&lt;Pair&lt;Int, String&gt;&gt;, List&lt;Pair&lt;Int, String&gt;&gt;&gt;? = null</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$return copy(id = id, returnValue = returnValue, progress = progress, stepsTreeFeed = null, stepsTreeIndexFeed = null)</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator : Principal</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator$/** * Returns an [InvocationContext], which is equivalent to this object but expressed using the successor to this * class hierarchy (which is now deprecated). The returned object has less information than it could have, so * prefer to use fetch an invocation context directly if you can (e.g. in [net.corda.core.messaging.StateMachineInfo]) */ val invocationContext: InvocationContext get() { val unknownName = CordaX500Name("UNKNOWN", "UNKNOWN", "GB") var actor: Actor? = null val origin: InvocationOrigin when (this) { is FlowInitiator.RPC -&gt; { actor = Actor(Actor.Id(this.username), AuthServiceId("UNKNOWN"), unknownName) origin = InvocationOrigin.RPC(actor) } is FlowInitiator.Peer -&gt; origin = InvocationOrigin.Peer(this.party.name) is FlowInitiator.Service -&gt; origin = InvocationOrigin.Service(this.serviceClassName, unknownName) FlowInitiator.Shell -&gt; origin = InvocationOrigin.Shell is FlowInitiator.Scheduled -&gt; origin = InvocationOrigin.Scheduled(this.scheduledState) } return InvocationContext.newInstance(origin = origin, actor = actor) }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.getCounterpartyFlowInfo()", level = DeprecationLevel.WARNING) @Suspendable fun getFlowInfo(otherParty: Party): FlowInfo</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.sendAndReceive()", level = DeprecationLevel.WARNING) @Suspendable open fun &lt;R : Any&gt; sendAndReceive(receiveType: Class&lt;R&gt;, otherParty: Party, payload: Any): UntrustworthyData&lt;R&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun &lt;R : Any&gt; receiveAll(receiveType: Class&lt;R&gt;, sessions: List&lt;FlowSession&gt;, maySkipCheckpoint: Boolean = false): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun receiveAllMap(sessions: Map&lt;FlowSession, Class&lt;out Any&gt;&gt;, maySkipCheckpoint: Boolean = false): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun initiateFlow(destination: Destination): FlowSession</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun waitForStateConsumption(stateRefs: Set&lt;StateRef&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Throws(FlowException::class) fun checkFlowPermission(permissionName: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun recordAuditEvent(eventType: String, comment: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTree(): DataFeed&lt;List&lt;Pair&lt;Int, String&gt;&gt;, List&lt;Pair&lt;Int, String&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTreeIndex(): DataFeed&lt;Int, Int&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * @suppress * Internal only. Reference to the [co.paralleluniverse.fibers.Fiber] instance that is the top level controller for * the entire flow. When inside a flow this is equivalent to [co.paralleluniverse.strands.Strand.currentStrand]. This * is public only because it must be accessed across module boundaries. */ var stateMachine: FlowStateMachine&lt;*&gt; @CordaInternal get() = _stateMachine ?: throw IllegalStateException( "You cannot access the flow's state machine until the flow has been started.") @CordaInternal set(value) { _stateMachine = value }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Override this to provide a [ProgressTracker]. If one is provided and stepped, the framework will do something * helpful with the progress reports e.g record to the audit service. If this flow is invoked as a subflow of another, * then the tracker will be made a child of the current step in the parent. If it's null, this flow doesn't track * progress. * * Note that this has to return a tracker before the flow is invoked. You can't change your mind half way * through. */ open val progressTracker: ProgressTracker? = DEFAULT_TRACKER()</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity to use for this flow. This will be one of the multiple identities that belong to this node. * This is the same as calling `ourIdentityAndCert.party`. * @see NodeInfo.legalIdentities * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentity: Party get() = stateMachine.ourIdentity</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity, with certificate, to use for this flow. This will be one of the multiple identities that * belong to this node. * @see NodeInfo.legalIdentitiesAndCerts * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentityAndCert: PartyAndCertificate get() { return serviceHub.myInfo.legalIdentitiesAndCerts.find { it.party == stateMachine.ourIdentity } ?: throw IllegalStateException("Identity specified by ${stateMachine.id} (${stateMachine.ourIdentity}) is not one of ours!") }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$?:</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable @JvmOverloads open</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable internal</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$private</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic.Companion$throw FlowException("Attempt to sleep for longer than 5 minutes is not supported. Consider using SchedulableState.")</ID>
    <ID>MaxLineLength:FlowLogicRef.kt$FlowLogicRef</ID>
    <ID>MaxLineLength:FlowSession.kt$Destination</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * If the destination on the other side of this session is a [Party] then returns that, otherwise throws [IllegalStateException]. * * Only use this method if it's known the other side is a [Party], otherwise use [destination]. * * @throws IllegalStateException if the other side is not a [Party]. * @see destination */ abstract val counterparty: Party</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * The [Destination] on the other side of this session. In the case of a session created by [FlowLogic.initiateFlow] this is the same * destination as the one passed to that function. */ abstract val destination: Destination</ID>
    <ID>MaxLineLength:FlowStateMachine.kt$FlowStateMachine$@Suspendable fun &lt;SUSPENDRETURN : Any&gt; suspend(ioRequest: FlowIORequest&lt;SUSPENDRETURN&gt;, maySkipCheckpoint: Boolean): SUSPENDRETURN</ID>
    <ID>MaxLineLength:FungibleAsset.kt$InsufficientBalanceException : FlowException</ID>
    <ID>MaxLineLength:Id.kt$Id.Companion$ @DeleteForDJVM @JvmStatic fun &lt;V : Any&gt; newInstance(value: V, entityType: String? = null, timestamp: Instant = now())</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ @Throws(IllegalArgumentException::class) fun registerKeyToParty(key: PublicKey, party: Party)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ fun wellKnownPartyFromX500Name(name: CordaX500Name): Party?</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Deprecated("This method has been deprecated in favour of using a new way to generate and use confidential identities. See the new " + "confidential identities repository.")</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService${ // The original version of this would return the party as-is if it was a Party (rather than AnonymousParty), // however that means that we don't verify that we know who owns the key. As such as now enforce turning the key // into a party, and from there figure out the well known party. log.debug("Attempting to find wellKnownParty for: ${party.owningKey.hash}") val candidate = partyFromKey(party.owningKey) // TODO: This should be done via the network map cache, which is the authoritative source of well known identities return if (candidate != null) { require(party.nameOrNull() == null || party.nameOrNull() == candidate.name) { "Candidate party $candidate does not match expected $party" } wellKnownPartyFromX500Name(candidate.name) } else { null } }</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ fun &lt;T&gt; excludeHostNode(serviceHub: ServiceHub, map: Map&lt;Party, T&gt;): Map&lt;Party, T&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$(serviceHub.identityService.wellKnownPartyFromAnonymous(it) ?: if (ignoreUnrecognisedParties) return@mapNotNull null else throw IllegalArgumentException("Could not find Party for $it")) to it</ID>
    <ID>MaxLineLength:IdentityUtils.kt$groupAbstractPartyByWellKnownParty(serviceHub, publicKeys.map { AnonymousParty(it) }, ignoreUnrecognisedParties).mapValues { it.value.map { it.owningKey } }</ID>
    <ID>MaxLineLength:IdentityUtils.kt$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:InitiatedBy.kt$InitiatedBy</ID>
    <ID>MaxLineLength:InitiatingFlow.kt$InitiatingFlow</ID>
    <ID>MaxLineLength:Instances.kt$Instances</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: Class&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: KClass&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; KClass&lt;*&gt;.staticField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ fun &lt;T, U&gt; List&lt;T&gt;.lazyMapped(transform: (T, Int) -&gt; U): List&lt;U&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future. fun CertPath.validate(trustAnchor: TrustAnchor, checkRevocation: Boolean = false): PKIXCertPathValidatorResult</ID>
    <ID>MaxLineLength:InternalUtils.kt$?:</ID>
    <ID>MaxLineLength:InternalUtils.kt$@DeleteForDJVM fun InputStream.copyTo(target: Path, vararg options: CopyOption): Long</ID>
    <ID>MaxLineLength:InternalUtils.kt$DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$LazyMappedList&lt;T, U&gt; : AbstractList</ID>
    <ID>MaxLineLength:InternalUtils.kt$if (predicate(iterator.next())) throw IllegalArgumentException("Collection contains more than one matching element.")</ID>
    <ID>MaxLineLength:InternalUtils.kt$val Class&lt;*&gt;.packageNameOrNull: String? // This intentionally does not go via `package` as that code path is slow and contended and just ends up doing this. get() { val name = this.getName() val i = name.lastIndexOf('.') if (i != -1) { return name.substring(0, i) } else { return null } }</ID>
    <ID>MaxLineLength:InvocationContext.kt$Actor.Companion$@JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name): Actor</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext$@CordaSerializable data</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(origin: InvocationOrigin, trace: Trace = Trace.newInstance(), actor: Actor? = null, externalTrace: Trace? = null, impersonatedActor: Actor? = null)</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun peer(party: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun rpc(actor: Actor, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun scheduled(scheduledState: ScheduledStateRef, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun shell(trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$ fun collectCertificates(jar: JarInputStream): List&lt;X509Certificate&gt;</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$/** * @see &lt;https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File&gt; * Additionally accepting *.EC as its valid for [java.util.jar.JarVerifier] and jarsigner @see https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jarsigner.html, * temporally treating META-INF/INDEX.LIST as unsignable entry because [java.util.jar.JarVerifier] doesn't load its signers. */ private val unsignableEntryName = "META-INF/(?:(?:.*[.](?:SF|DSA|RSA|EC)|SIG-.*)|INDEX\\.LIST)".toRegex()</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun externalIdForPublicKey(publicKey: PublicKey): UUID?</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKey(externalId: UUID): PublicKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean, externalId: UUID): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(bytes: ByteArray, publicKey: PublicKey): DigitalSignature.WithKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature</ID>
    <ID>MaxLineLength:LazyPool.kt$LazyPool&lt;A&gt;</ID>
    <ID>MaxLineLength:LazyStickyPool.kt$LazyStickyPool&lt;A : Any&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ @Throws(TransactionVerificationException::class) fun verify()</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; commandsOfType(clazz: Class&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; filterCommands(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; findCommand(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; getCommand(index: Int): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; inputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; referenceInputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$"Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate."</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** * Network parameters that were in force when the transaction was constructed. This is nullable only for backwards * compatibility for serialized transactions. In reality this field will always be set when on the normal codepaths. */ override val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */ val attachments: List&lt;Attachment&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** Random data used to make the transaction hash unpredictable even if the contents can be predicted; needed to avoid some obscure attacks. */ val privacySalt: PrivacySalt</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** The notary that the tx uses, this must be the same as the notary of all the inputs, or null if there are no inputs. */ override val notary: Party?</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$// Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline fun &lt;reified T : ContractState&gt; referenceInputRefsOfType(): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$logger</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return inputs.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return references.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.")</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$val deserializedOutputs = deserialiseComponentGroup(componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // Switch thread local deserialization context to using a cached attachments classloader. This classloader enforces various rules // like no-overlap, package namespace ownership and (in future) deterministic Java. return AttachmentsClassLoaderBuilder.withAttachmentsClassloaderContext( this.attachments + extraAttachments, getParamsWithGoo(), id, isAttachmentTrusted = isAttachmentTrusted) { transactionClassLoader -&gt; // Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader) } }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // This path is triggered if someone used old constructors that were accidentally exposed; darn Kotlin's lack of package-private // visibility! We did originally try to maintain verification codepaths that supported lack of network parameters, but, it // got too convoluted and people kept just !! asserting the nullity away because on normal codepaths this is always set. logger.warn("Network parameters on the LedgerTransaction with id: $id are null. Please don't use deprecated constructors of the LedgerTransaction. " + "Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate.") // Roll the dice - we're probably in flow context if we got here at all, which means we can fish the current params out. try { params = getParamsFromFlowLogic() } catch (e: UnsupportedOperationException) { // Inside DJVM, ignore. } if (params == null) throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.") }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction.Companion$return LedgerTransaction(inputs, outputs, commands, attachments, id, notary, timeWindow, privacySalt, networkParameters, references).apply { this.componentGroups = componentGroups this.serializedInputs = serializedInputs this.serializedReferences = serializedReferences this.isAttachmentTrusted = isAttachmentTrusted }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction.InOutGroup$@KeepForDJVM data</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateNameAttribute(normalizedNameAttribute: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateOrganization(normalizedOrganization: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$@Deprecated("Use validateOrganization instead", replaceWith = ReplaceWith("validateOrganization(normalizedLegalName)"))</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.CapitalLetterRule$require(legalName == capitalizedLegalName) { "Legal name should be capitalized. i.e. '$capitalizedLegalName'" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.MustHaveAtLeastTwoLettersRule$require(legalName.count { it.isLetter() } &gt;= 2) { "Illegal input legal name '$legalName'. Legal name must have at least two letters" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeNormalizationRule$require(legalName == normalize(legalName)) { "Legal name must be normalized. Please use 'normalize' to normalize the legal name before validation." }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeRangeRule$val illegalChars = legalName.toCharArray().filter { Character.UnicodeBlock.of(it) !in supportScriptsSet }.size</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$ComponentVisibilityException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredComponentGroup : ComponentGroup</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkAllComponentsVisible(componentGroupEnum: ComponentGroupEnum)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkCommandVisibility(publicKey: PublicKey)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ fun checkWithFun(checkingFun: (Any) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Did not receive components for group ${componentGroupEnum.ordinal} and cannot verify they didn't exist in the original wire transaction"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Partial Merkle tree root and advertised full Merkle tree root for component group $groupIndex do not match"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$val groupFullRoot = MerkleTree.getMerkleTree(group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }).hash</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck(groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group $groupIndex" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(group.groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group ${group.groupIndex}" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(groupPartialRoot == groupFullRoot) { "Some components for group ${group.groupIndex} are not visible" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentGroups.add(FilteredComponentGroup(groupIndex, value, filteredComponentNonces[groupIndex]!!, createPartialMerkleTree(groupIndex)))</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val filteredComponentHashes: MutableMap&lt;Int, MutableList&lt;SecureHash&gt;&gt; = hashMapOf() // Required for partial Merkle tree generation.</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex]</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ if (!filtering.test(t)) return val group = filteredSerialisedComponents[componentGroupIndex] // Because the filter passed, we know there is a match. We also use first Vs single as the init function // of WireTransaction ensures there are no duplicated groups. val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex] if (group == null) { // As all of the helper Map structures, like availableComponentNonces, availableComponentHashes // and groupsMerkleRoots, are computed lazily via componentGroups.forEach, there should always be // a match on Map.get ensuring it will never return null. filteredSerialisedComponents[componentGroupIndex] = mutableListOf(serialisedComponent) filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } else { group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } // If at least one command is visible, then all command-signers should be visible as well. // This is required for visibility purposes, see FilteredTransaction.checkAllCommandsVisible() for more details. if (componentGroupIndex == COMMANDS_GROUP.ordinal &amp;&amp; !signersIncluded) { signersIncluded = true val signersGroupIndex = SIGNERS_GROUP.ordinal // There exist commands, thus the signers group is not empty. val signersGroupComponents = wtx.componentGroups.first { it.groupIndex == signersGroupIndex } filteredSerialisedComponents[signersGroupIndex] = signersGroupComponents.components.toMutableList() filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList() filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList() } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ wtx.inputs.forEachIndexed { internalIndex, it -&gt; filter(it, INPUTS_GROUP.ordinal, internalIndex) } wtx.outputs.forEachIndexed { internalIndex, it -&gt; filter(it, OUTPUTS_GROUP.ordinal, internalIndex) } wtx.commands.forEachIndexed { internalIndex, it -&gt; filter(it, COMMANDS_GROUP.ordinal, internalIndex) } wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) } if (wtx.notary != null) filter(wtx.notary, NOTARY_GROUP.ordinal, 0) if (wtx.timeWindow != null) filter(wtx.timeWindow, TIMEWINDOW_GROUP.ordinal, 0) // Note that because [inputs] and [references] share the same type [StateRef], we use a wrapper for references [ReferenceStateRef], // when filtering. Thus, to filter-in all [references] based on type, one should use the wrapper type [ReferenceStateRef] and not [StateRef]. // Similar situation is for network parameters hash and attachments, one should use wrapper [NetworkParametersHash] and not [SecureHash]. wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) } wtx.networkParametersHash?.let { filter(NetworkParametersHash(it), PARAMETERS_GROUP.ordinal, 0) } // It is highlighted that because there is no a signers property in TraversableTransaction, // one cannot specifically filter them in or out. // The above is very important to ensure someone won't filter out the signers component group if at least one // command is included in a FilteredTransaction. // It's sometimes possible that when we receive a WireTransaction for which there is a new or more unknown component groups, // we decide to filter and attach this field to a FilteredTransaction. // An example would be to redact certain contract state types, but otherwise leave a transaction alone, // including the unknown new components. wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransactionVerificationException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override val outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = deserialiseComponentGroup(componentGroups, TransactionState::class, OUTPUTS_GROUP)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$val timeWindows: List&lt;TimeWindow&gt; = deserialiseComponentGroup(componentGroups, TimeWindow::class, TIMEWINDOW_GROUP)</ID>
    <ID>MaxLineLength:MerkleTree.kt$MerkleTree$Node : MerkleTree</ID>
    <ID>MaxLineLength:MissingAttachmentsException.kt$MissingAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$"${contractsClassName ?: states.map { it.contract }.distinct()}${minimumRequiredContractClassVersion?.let { ", minimum required contract class version $minimumRequiredContractClassVersion"}}. "</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$@JvmOverloads constructor(val states: List&lt;TransactionState&lt;ContractState&gt;&gt;, contractsClassName: String? = null, minimumRequiredContractClassVersion: Version? = null)</ID>
    <ID>MaxLineLength:NetworkHostAndPort.kt$NetworkHostAndPort.Companion$ @JvmStatic fun parse(str: String): NetworkHostAndPort</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCache$ fun getNodeByLegalIdentity(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodeByLegalName(name: CordaX500Name): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodesByLegalName(name: CordaX500Name): List&lt;NodeInfo&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun track(): DataFeed&lt;List&lt;NodeInfo&gt;, NetworkMapCache.MapChange&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$/** * A list of notary services available on the network. * * Note that the identities are sorted based on legal name, and the ordering might change once new notaries are introduced. */ val notaryIdentities: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters$whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations</ID>
    <ID>MaxLineLength:NetworkParametersService.kt$NetworkParametersService$/** * For backwards compatibility, this parameters hash will be used for resolving historical transactions in the chain. */ val defaultHash: SecureHash</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getEpochFromHash(hash: SecureHash): Int?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getHistoricNotary(party: Party): NotaryInfo?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun lookupSigned(hash: SecureHash): SignedDataWithCert&lt;NetworkParameters&gt;?</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfo</ID>
    <ID>MaxLineLength:NonEmptySet.kt$NonEmptySet.Companion$elements.forEach { copy += it }</ID>
    <ID>MaxLineLength:NotaryChangeFlow.kt$NotaryChangeFlow$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$ private fun checkNewNotaryWhitelisted()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$@Deprecated("NotaryChangeLedgerTransaction should not be created directly, use NotaryChangeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$val inputPositionIndex: Map&lt;StateRef, Int&gt; = inputs.mapIndexed { index, stateAndRef -&gt; stateAndRef.ref to index }.toMap()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @CordaInternal internal fun resolveOutputComponent(services: ServicesForResolution, stateRef: StateRef, params: NetworkParameters): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @DeleteForDJVM fun resolve(services: ServiceHub, sigs: List&lt;TransactionSignature&gt;)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING) constructor(inputs: List&lt;StateRef&gt;, notary: Party, newNotary: Party) : this(listOf(inputs, notary, newNotary).map { it.serialize() })</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$return NotaryChangeLedgerTransaction.create(resolvedInputs, notary, newNotary, id, sigs, resolvedNetworkParameters)</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"${consumedStates.asSequence().joinToString(",\n", limit = 5) { it.key.toString() + " -&gt; " + it.value }}.\n"</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"To find out if any of the conflicting transactions have been generated by this node you can use the hashLookup Corda shell command."</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$override</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.TimeWindowInvalid$override fun toString()</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.WrongNotary$@Deprecated("Deprecated since platform version 4. This object is no longer used, [TransactionInvalid] will be reported in case of notary mismatch")</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryException$/** Id of the transaction to be notarised. Can be _null_ if an error occurred before the id could be resolved. */ val txId: SecureHash? = null</ID>
    <ID>MaxLineLength:NotaryError.kt$StateConsumptionDetails$fun copy(hashOfTransactionId: SecureHash): StateConsumptionDetails</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$ private fun generateRequestSignature(): NotarisationRequestSignature</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$"Notary $notaryParty is not on the network parameter whitelist. A non-whitelisted notary can only be used for notary change transactions"</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$?:</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$NotarySendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$check</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$it is StateRef || it is ReferenceStateRef || it is TimeWindow || it == notaryParty || it is NetworkParametersHash</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$protected</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val historicNotary = (serviceHub.networkParametersService as NetworkParametersStorage).getHistoricNotary(notaryParty) ?: throw IllegalStateException("The notary party $notaryParty specified by transaction ${stx.id}, is not recognised as a current or historic notary.")</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val notarisationRequest = NotarisationRequest(stx.inputs.map { it.copy(txhash = SecureHash.parse(it.txhash.toString())) }, stx.id)</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$@Suspendable override</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$net.corda.core.flows.NotaryFlow.kt</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow : FlowLogic</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$ @Suspendable abstract fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$"The notary specified on the transaction: [$notary] does not match the notary service's identity: [${service.notaryIdentityKey}] "</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$abstract</ID>
    <ID>MaxLineLength:NotaryUtils.kt$"Expected a signature by ${intendedSigner.owningKey.toBase58String()}, but received by ${signature.by.toBase58String()}}"</ID>
    <ID>MaxLineLength:NotaryUtils.kt$require(notary.owningKey.isFulfilledBy(signingKeys)) { "Insufficient signatures to fulfill the notary signing requirement for $notary" }</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationPayload</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest$/** States this request specifies to be consumed. Sorted to ensure the serialized form does not get affected by the state order. */ val statesToConsume: List&lt;StateRef&gt; get() = _statesToConsumeSorted // Getter required for AMQP serialization</ID>
    <ID>MaxLineLength:NullKeys.kt$NullKeys$/** A signature with a key and value of zero. Useful when you want a signature object that you know won't ever be used. */ val NULL_SIGNATURE = TransactionSignature(ByteArray(32), NullPublicKey, SignatureMetadata(1, -1))</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$PartialTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$if (!leafIndexHelper(leaf, this.root, flagPath)) throw MerkleTreeException("The provided hash $leaf is not in the tree.")</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$ fun rootAndUsedHashes(node: PartialTree, usedHashes: MutableList&lt;SecureHash&gt;): SecureHash</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$// Check if a MerkleTree is full binary tree. Returns the height of the tree if full, otherwise throws exception. private fun checkFull(tree: MerkleTree, level: Int = 0): Int</ID>
    <ID>MaxLineLength:Party.kt$Party : DestinationAbstractParty</ID>
    <ID>MaxLineLength:Party.kt$Party$constructor(certificate: X509Certificate) : this(CordaX500Name.build(certificate.subjectX500Principal), Crypto.toSupportedPublicKey(certificate.publicKey))</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$require(role?.isIdentity ?: false) { "Party certificate ${certificate.subjectDN} does not have a well known or confidential identity role. Found: $role" }</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("Child certificate whose issuer includes a Corda role, must also specify Corda role")</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("The issuing certificate for $certificateString has role $parentRole, expected one of ${role.validParents}")</ID>
    <ID>MaxLineLength:PathUtils.kt$ fun Path.attributes(vararg options: LinkOption): BasicFileAttributes</ID>
    <ID>MaxLineLength:PathUtils.kt$inline</ID>
    <ID>MaxLineLength:PersistentTypes.kt$DirectStatePersistable : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$IndirectStatePersistable&lt;T : DirectStatePersistable&gt; : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$SchemaCrossReferenceReport</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$annotations.any { annotation -&gt; annotation.toString().startsWith("@javax.persistence.") &amp;&amp; annotation !is javax.persistence.Transient }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ field -&gt; field.type.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(field.type.enclosingClass) &amp;&amp; hasJpaAnnotation(field.declaredAnnotations) &amp;&amp; field.type.enclosingClass != schema.javaClass }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ method -&gt; method.returnType.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(method.returnType.enclosingClass) &amp;&amp; method.returnType.enclosingClass != schema.javaClass &amp;&amp; hasJpaAnnotation(method.declaredAnnotations) }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator.SchemaCrossReferenceReport$"MappedSchema '${schema.substringAfterLast(".")}' entity '$entity' field '$fieldOrMethod' is of type '$fieldOrMethodType' "</ID>
    <ID>MaxLineLength:PersistentTypes.kt$PersistentState : DirectStatePersistable</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$/** * A list of all steps label in this ProgressTracker and the children, with the indent level provided starting at zero. * Note that UNSTARTED is never counted, and DONE is only counted at the calling level. */ val allStepsLabels: List&lt;Pair&lt;Int, String&gt;&gt; get() = _allStepsLabels()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$if (it is Change.Structural || it is Change.Rendering) rebuildStepsTree() else recalculateStepsTreeIndex()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$log.warnOnce("Found ProgressTracker Step(s) with the same label: ${labels.groupBy { it }.filter { it.value.size &gt; 1 }.map { it.key }}")</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ // This gets the index of the current step in the context of this progress tracker, so it will always be at the top level in // the allStepsCache. val index = _allStepsCache.indexOf(Pair(0, currentStep)) return if (index &gt;= 0) index else 0 }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ steps.forEach { configureChildTrackerForStep(it) } // Immediately update the step tree observable to ensure the first update the client receives is the initial state of the progress // tracker. _stepsTreeChanges.onNext(allStepsLabels) this.currentStep = UNSTARTED }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker.Step$private fun definitionLocation(): String</ID>
    <ID>MaxLineLength:ProviderMap.kt$// Among the others, we should register [CordaSecurityProvider] as the first provider, to ensure that when invoking [SecureRandom()] // the [platformSecureRandom] is returned (which is registered in CordaSecurityProvider). // Note that internally, [SecureRandom()] will look through all registered providers. // Then it returns the first PRNG algorithm of the first provider that has registered a SecureRandom // implementation (in our case [CordaSecurityProvider]), or null if none of the registered providers supplies // a SecureRandom implementation. Security.insertProviderAt(it, 1) // The position is 1-based.</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This map is required to defend against users that forcibly call Security.addProvider / Security.removeProvider // that could cause unexpected and suspicious behaviour. // i.e. if someone removes a Provider and then he/she adds a new one with the same name. // The val is private to avoid any harmful state changes. val providerMap = listOf(cordaBouncyCastleProvider, cordaSecurityProvider, bouncyCastlePQCProvider).map { it.name to it }.toMap()</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This registration is needed for reading back EdDSA key from java keystore. // TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider. Security.addProvider(it)</ID>
    <ID>MaxLineLength:ProviderMap.kt$&lt;no name provided&gt;$override fun generatePublic(keyInfo: SubjectPublicKeyInfo)</ID>
    <ID>MaxLineLength:ProviderMap.kt$@DeleteForDJVM fun platformSecureRandomFactory(): SecureRandom</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$AndComposition : AttachmentQueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$OrComposition : AttachmentQueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(uploaderCondition: ColumnPredicate&lt;String&gt;?, filenameCondition: ColumnPredicate&lt;String&gt;?) : this(uploaderCondition, filenameCondition, null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun isSigned(isSignedPredicate: ColumnPredicate&lt;Boolean&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withContractClassNames(contractClassNamesPredicate: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withFilename(filenamePredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withSigners(signersPredicate: ColumnPredicate&lt;List&lt;PublicKey&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploadDate(uploadDatePredicate: ColumnPredicate&lt;Instant&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploader(uploaderPredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withVersion(versionPredicate: ColumnPredicate&lt;Int&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$uploadDateCondition: ColumnPredicate&lt;Instant&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$val contractClassNamesCondition: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$val versionCondition: ColumnPredicate&lt;Int&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentsQueryCriteriaParser : BaseQueryCriteriaParser</ID>
    <ID>MaxLineLength:QueryCriteria.kt$BaseQueryCriteriaParser&lt;Q: GenericQueryCriteria&lt;Q, P&gt;, in P: BaseQueryCriteriaParser&lt;Q,P,S&gt;, in S : BaseSort&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$AndVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$OrVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$AndComposition : QueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$OrComposition : QueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, owner: List&lt;AbstractParty&gt;? = null, quantity: ColumnPredicate&lt;Long&gt;? = null, issuer: List&lt;AbstractParty&gt;? = null, issuerRef: List&lt;OpaqueBytes&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, linearId: List&lt;UniqueIdentifier&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withExpression(expression: CriteriaExpression&lt;L, Boolean&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?) : this(status, contractStateTypes, participants = null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 3) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?) : this( status, contractStateTypes, stateRefs, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 4) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?) : this( status, contractStateTypes, stateRefs, notary, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 5) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?, softLockingCondition: SoftLockingCondition?) : this( status, contractStateTypes, stateRefs, notary, softLockingCondition, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraintTypes(constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraints(constraints: Set&lt;Vault.ConstraintInfo&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withSoftLockingCondition(softLockingCondition: SoftLockingCondition): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$/** * Note: use [PageSpecification] to correctly handle a number of bounded pages of a pre-configured page size. */ // Here we subtract 1 to allow the Vault to figure out whether there are more results and pages by querying for `pageSize + 1`. const val MAX_PAGE_SIZE = Int.MAX_VALUE - 1</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.like(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; `in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.avg(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.max(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.min(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.sum(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.count()</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;O, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; compare(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Column.Companion$when (property) { // This is to ensure that, for a JPA Entity, a field declared in a MappedSuperclass will not cause Hibernate to reject a query referencing it. // TODO remove the cast and access the owner properly after it will be exposed as Kotlin's public API (https://youtrack.jetbrains.com/issue/KT-24170). is CallableReference -&gt; ((property as CallableReference).owner as KClass&lt;*&gt;).javaObjectType else -&gt; property.javaGetter!!.declaringClass }</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$BinaryComparison&lt;C : Comparable&lt;C&gt;&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$CollectionExpression&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$EqualityComparison&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$BinaryLogical&lt;O&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$ColumnPredicateExpression&lt;O, C&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveStateAndRefFlow&lt;out T : ContractState&gt; : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$logger.trace { "Receiving a transaction (but without checking the signatures) from ${otherSideSession.counterparty}" }</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$private val statesToRecord: StatesToRecord = StatesToRecord.NONE</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO This can also be done in parallel. See comment to [fetchMissingAttachments] above. @Suspendable fun fetchMissingNetworkParameters(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO: This could be done in parallel with other fetches for extra speed. @Suspendable fun fetchMissingAttachments(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$/** * Resolves and validates the dependencies of the specified [SignedTransaction]. Fetches the attachments, but does * *not* validate or store the [SignedTransaction] itself. * * @return a list of verified [SignedTransaction] objects, in a depth-first order. */ constructor(transaction: SignedTransaction, otherSide: FlowSession, statesToRecord: StatesToRecord = StatesToRecord.NONE) : this(transaction, transaction.dependencies, otherSide, statesToRecord)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow${ // TODO This error should actually cause the flow to be sent to the flow hospital to be retried val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" } // Fetch missing parameters flow was added in version 4. This check is needed so we don't end up with node V4 sending parameters // request to node V3 that doesn't know about this protocol. fetchNetParamsFromCounterpart = counterpartyPlatformVersion &gt;= 4 if (initialTx != null) { fetchMissingAttachments(initialTx) fetchMissingNetworkParameters(initialTx) } val resolver = (serviceHub as ServiceHubCoreInternal).createTransactionsResolver(this) resolver.downloadDependencies() otherSide.send(FetchDataFlow.Request.End) // Finish fetching data. // If transaction resolution is performed for a transaction where some states are relevant, then those should be // recorded if this has not already occurred. val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord resolver.recordDependencies(usedStatesToRecord) }</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$ @JvmStatic fun parse(str: String?): SHA256</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$else -&gt; throw IllegalArgumentException("Provided string is ${it.size} bytes not 32 bytes in hex: $str")</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$@Suspendable protected open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction))</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow${ // The first payload will be the transaction data, subsequent payload will be the transaction/attachment/network parameters data. var payload = payload // Depending on who called this flow, the type of the initial payload is different. // The authorisation logic is to maintain a dynamic list of transactions that the caller is authorised to make based on the transactions that were made already. // Each time an authorised transaction is requested, the input transactions are added to the list. // Once a transaction has been requested, it will be removed from the authorised list. This means that it is a protocol violation to request a transaction twice. val authorisedTransactions = when (payload) { is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction)) is SignedTransaction -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload)) is RetrieveAnyTransactionPayload -&gt; TransactionAuthorisationFilter(acceptAll = true) is List&lt;*&gt; -&gt; TransactionAuthorisationFilter().addAuthorised(payload.flatMap { stateAndRef -&gt; if (stateAndRef is StateAndRef&lt;*&gt;) { getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash } else { throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?") } }.toSet()) else -&gt; throw Exception("Unknown payload type: ${payload::class.java} ?") } // This loop will receive [FetchDataFlow.Request] continuously until the `otherSideSession` has all the data they need // to resolve the transaction, a [FetchDataFlow.EndRequest] will be sent from the `otherSideSession` to indicate end of // data request. while (true) { val dataRequest = sendPayloadAndReceiveDataRequest(otherSideSession, payload).unwrap { request -&gt; when (request) { is FetchDataFlow.Request.Data -&gt; { // Security TODO: Check for abnormally large or malformed data requests verifyDataRequest(request) request } FetchDataFlow.Request.End -&gt; return null } } payload = when (dataRequest.dataType) { FetchDataFlow.DataType.TRANSACTION -&gt; dataRequest.hashes.map { txId -&gt; if (!authorisedTransactions.isAuthorised(txId)) { throw FetchDataFlow.IllegalTransactionRequest(txId) } val tx = serviceHub.validatedTransactions.getTransaction(txId) ?: throw FetchDataFlow.HashNotFound(txId) authorisedTransactions.removeAuthorised(tx.id) authorisedTransactions.addAuthorised(getInputTransactions(tx)) tx } FetchDataFlow.DataType.ATTACHMENT -&gt; dataRequest.hashes.map { serviceHub.attachments.openAttachment(it)?.open()?.readFully() ?: throw FetchDataFlow.HashNotFound(it) } FetchDataFlow.DataType.PARAMETERS -&gt; dataRequest.hashes.map { (serviceHub.networkParametersService as NetworkParametersStorage).lookupSigned(it) ?: throw FetchDataFlow.MissingNetworkParameters(it) } } } }</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow.TransactionAuthorisationFilter$private</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow$open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SerializationAPI.kt$@DeleteForDJVM inline</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$ fun withPreferredSerializationVersion(magic: SerializationMagic): SerializationContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the carpenter will happily synthesis classes that implement interfaces containing methods that are not * getters for any AMQP fields. Invoking these methods will throw an [AbstractMethodError]. If false then an exception * will be thrown during deserialization instead. * * The default is false. */ val lenientCarpenterEnabled: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the serialization evolver will fail if the binary to be deserialized contains more fields then the current object from * the classpath. * * The default is false. */ val preventDataLoss: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ abstract fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ fun &lt;T&gt; asCurrent(block: SerializationFactory.() -&gt; T): T</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * A context to use as a default if you do not require a specially configured context. It will be the current context * if the use is somehow nested (see [currentContext]). */ val defaultContext: SerializationContext get() = currentContext ?: effectiveSerializationEnv.p2pContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current context used to start serialization/deserialization. */ val currentContext: SerializationContext? get() = _currentContext.get()</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$abstract</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * A default factory for serialization/deserialization, taking into account the [currentFactory] if set. */ val defaultFactory: SerializationFactory get() = currentFactory ?: effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current factory used to start serialization/deserialization. */ val currentFactory: SerializationFactory? get() = _currentFactory.get()</ID>
    <ID>MaxLineLength:SerializationAPI.kt$context: SerializationContext = serializationFactory.defaultContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$inline</ID>
    <ID>MaxLineLength:SerializationAnnotations.kt$CordaSerializable</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$"Expected exactly 1 of {${serializationEnvFields.joinToString(", ") { it.name }}} but got: {${it.joinToString(", ") { it.first }}}"</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$(e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread")</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$private val serializationEnvFields = listOf(_nodeSerializationEnv, _driverSerializationEnv, _contextSerializationEnv, _inheritableContextSerializationEnv)</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken$fun registerWithContext(context: SerializeAsTokenContext, toBeTokenized: SerializeAsToken)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken.Companion$fun &lt;T : SerializeAsToken&gt; singletonSerializationToken(toBeTokenized: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializeAsToken : SerializeAsToken</ID>
    <ID>MaxLineLength:SerializationWhitelist.kt$SerializationWhitelist$/** * Optionally whitelist types for use in object serialization, as we lock down the types that can be serialized. * * For example, if you add a new [net.corda.core.contracts.ContractState] it needs to be whitelisted. You can do that * either by adding the [net.corda.core.serialization.CordaSerializable] annotation or via this method. */ val whitelist: List&lt;Class&lt;*&gt;&gt;</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction, publicKey: PublicKey): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction): TransactionSignature</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(signedTransaction: SignedTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$/** * A network map contains lists of nodes on the network along with information about their identity keys, services * they provide and host names or IP addresses where they can be connected to. The cache wraps around a map fetched * from an authoritative service, and adds easy lookup of the data stored within it. Generally it would be initialised * with a specified network map service, which it fetches data from and then subscribes to updates of. */ val networkMapCache: NetworkMapCache</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(filteredTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(signedTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$private</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$signInitialTransaction(builder, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$val stx = validatedTransactions.getTransaction(stateRef.txhash) ?: throw TransactionResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServicesForResolution$ // TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load // as the existing transaction store will become encrypted at some point @Throws(TransactionResolutionException::class) fun loadStates(stateRefs: Set&lt;StateRef&gt;): Set&lt;StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ServiceHub.kt$StatesToRecord$ONLY_RELEVANT</ID>
    <ID>MaxLineLength:ServiceHubCoreInternal.kt$ServiceHubCoreInternal : ServiceHub</ID>
    <ID>MaxLineLength:SignableData.kt$SignableData</ID>
    <ID>MaxLineLength:SignatureMetadata.kt$SignatureMetadata</ID>
    <ID>MaxLineLength:SignatureScheme.kt$SignatureScheme</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM fun resolveNotaryChangeTransaction(services: ServiceHub)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyContractUpgradeTransaction(services: ServicesForResolution, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyNotaryChangeTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ private fun copyWithCache(sigList: Iterable&lt;TransactionSignature&gt;): SignedTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR.</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$"""Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |"""</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$(services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow()</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Cache the deserialized form of the transaction. This is useful when building a transaction or collecting signatures. */ @Volatile @Transient private var cachedTransaction: CoreTransaction? = null</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Returns the contained [WireTransaction], or throws if this is a notary change or contract upgrade transaction. */ val tx: WireTransaction get() = coreTransaction as WireTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$?:</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$@Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$SignaturesMissingException : NamedByHashSignatureExceptionCordaThrowable</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$if (e.cause is NotSerializableException &amp;&amp; e.cause.cause is ClassNotFoundException &amp;&amp; e.cause.cause!!.message != null) { verifyWithExtraDependency(e.cause.cause!!.message!!.replace(".", "/"), ltx, services, e) } else { throw e }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$is FilteredTransaction -&gt; throw IllegalStateException("Persistence of filtered transactions is not supported.")</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$private</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$require(sigs.isNotEmpty()) { "Tried to instantiate a ${SignedTransaction::class.java.simpleName} without any signatures " }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$throw TransactionVerificationException.TransactionNetworkParameterOrderingException(id, entry.value.first(), txNetworkParameters, params)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction${ // If that transaction was created with and after Corda 4 then just fail. // The lenient dependency verification is only supported for Corda 3 transactions. // To detect if the transaction was created before Corda 4 we check if the transaction has the NetworkParameters component group. if (this.networkParametersHash != null) { throw exception } val attachment = requireNotNull(services.attachments.internalFindTrustedAttachmentForClass(missingClass)) { """Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |""".trimMargin() } log.warn("""Detected that transaction ${this.id} does not contain all cordapp dependencies. |This may be the result of a bug in a previous version of Corda. |Attempting to verify using the additional trusted dependency: $attachment for class $missingClass. |Please check with the originator that this is a valid transaction.""".trimMargin()) (services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow() }</ID>
    <ID>MaxLineLength:SinglePartyNotaryService.kt$SinglePartyNotaryService$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer$// Here either one of two things has happened: // 1. The pointed-to state has not been seen by the resolver node. It is unlikely that this is the case. // The state can probably be obtained via subscribing to the data distribution group which created and // and maintains this data. // 2. Uh oh... The pointed-to state has been exited from the ledger! // It is unlikely this would ever happen as most reference data states will be created such that they cannot // be exited from the ledger. At this point there are two options; use an old consumed version of the state, // or don't use it at all. "The LinearState with ID ${pointer.id} is unknown to this node or it has been exited from the ledger."</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer&lt;T : LinearState&gt; : StatePointer</ID>
    <ID>MaxLineLength:StatePointer.kt$StaticPointer&lt;T : ContractState&gt; : StatePointer</ID>
    <ID>MaxLineLength:Structures.kt$Command$private fun commandDataToString()</ID>
    <ID>MaxLineLength:Structures.kt$CommandWithParties$@Deprecated("Should not be used in contract verification code as it is non-deterministic, will be disabled for some future target platform version onwards and will take effect only for CorDapps targeting those versions.")</ID>
    <ID>MaxLineLength:Structures.kt$Contract</ID>
    <ID>MaxLineLength:Structures.kt$Issued$require(issuer.reference.size &lt;= MAX_ISSUER_REF_SIZE) { "Maximum issuer reference size is $MAX_ISSUER_REF_SIZE." }</ID>
    <ID>MaxLineLength:Structures.kt$OwnableState$ fun withNewOwner(newOwner: AbstractParty): CommandAndState</ID>
    <ID>MaxLineLength:Structures.kt$PrivacySalt : OpaqueBytes</ID>
    <ID>MaxLineLength:Structures.kt$SchedulableState$ @DeleteForDJVM fun nextScheduledActivity(thisStateRef: StateRef, flowLogicRefFactory: FlowLogicRefFactory): ScheduledActivity?</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContract&lt;in OldState : ContractState, out NewState : ContractState&gt; : Contract</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContractWithLegacyConstraint&lt;in OldState : ContractState, out NewState : ContractState&gt; : UpgradedContract</ID>
    <ID>MaxLineLength:Structures.kt$return mapNotNull { if (it.state.data is T) StateAndRef(TransactionState(it.state.data, it.state.contract, it.state.notary), it.ref) else null }</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromOnly(fromTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromStartAndDuration(fromTime: Instant, duration: Duration): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun untilOnly(untilTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField$private val isAGlobalThreadBeingCreated: (Array&lt;StackTraceElement&gt;) -&gt; Boolean</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:ToggleField.kt$ThreadLeakException : RuntimeException</ID>
    <ID>MaxLineLength:Trace.kt$Trace.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(invocationId: InvocationId = InvocationId.newInstance(), sessionId: SessionId = SessionId(invocationId.value, invocationId.timestamp))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.InvocationId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:Trace.kt$Trace.SessionId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @Throws(MissingContractAttachments::class) fun toWireTransaction(services: ServicesForResolution): WireTransaction</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ Please contact the developer of the CorDapp and install the latest version, as this approach might be insecure.</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ fun setTimeWindow(time: Instant, timeTolerance: Duration)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, serializationContext: SerializationContext?): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$(allContractAttachments + attachments).toSortedSet().toList()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$?:</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@CordaInternal internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@Throws(AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$checkNotNull(notary) { "Need to specify a notary for the state, or set a default one on TransactionBuilder initialisation" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$inputStates != null -&gt; attachmentConstraintsTransition(inputStates.groupBy { it.constraint }.keys, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is CommandData -&gt; throw IllegalArgumentException("You passed an instance of CommandData, but that lacks the pubkey. You need to wrap it in a Command object first.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is ContractState -&gt; throw UnsupportedOperationException("Removed as of V1: please use a StateAndContract instead")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log.warnOnce("Signature constraints not available on network requiring a minimum platform version of 4. Current is: ${services.networkParameters.minimumPlatformVersion}.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private fun useWhitelistedByZoneAttachmentConstraint(contractClassName: ContractClassName, networkParameters: NetworkParameters)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(explicitAttachmentContracts.isEmpty() || explicitAttachmentContracts.groupBy { (ctr, _) -&gt; ctr }.all { (_, groups) -&gt; groups.size == 1 }) { "Multiple attachments set for the same contract." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$rootError is ClassNotFoundException -&gt; addMissingAttachment((rootError.message ?: throw e).replace(".", "/"), services, e)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$services: ServicesForResolution</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$useWhitelistedByZoneAttachmentConstraint(contractClassName, services.networkParameters) -&gt; WhitelistedByZoneAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val (allContractAttachments: Collection&lt;SecureHash&gt;, resolvedOutputs: List&lt;TransactionState&lt;ContractState&gt;&gt;) = selectContractAttachmentsAndOutputStateConstraints(services, serializationContext)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachments: Collection&lt;AttachmentId&gt; = contractAttachmentsAndResolvedOutputStates.map { it.first } + refStateContractAttachments</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val contractAttachmentsAndResolvedOutputStates: List&lt;Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;&gt; = allContracts.toSet() .map { ctr -&gt; handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val inputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = inputsWithTransactionState.map { it.state } .groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val outputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = outputs.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val referenceStateGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = referencesWithTransactionState.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedOutputStatesInTheOriginalOrder: List&lt;TransactionState&lt;ContractState&gt;&gt; = outputStates().map { os -&gt; resolvedStates.find { rs -&gt; rs.data == os.data &amp;&amp; rs.encumbrance == os.encumbrance }!! }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedStates: List&lt;TransactionState&lt;ContractState&gt;&gt; = contractAttachmentsAndResolvedOutputStates.mapNotNull { it.second } .flatten()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$when { // Sanity check. constraints.isEmpty() -&gt; throw IllegalArgumentException("Cannot transition from no constraints.") // Fail when combining the insecure AlwaysAcceptAttachmentConstraint with something else. constraints.size &gt; 1 &amp;&amp; constraints.any { it is AlwaysAcceptAttachmentConstraint } -&gt; throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.") // Multiple states with Hash constraints with different hashes. This should not happen as we checked already. constraints.size &gt; 1 &amp;&amp; constraints.all { it is HashAttachmentConstraint } -&gt; throw IllegalArgumentException("Cannot mix HashConstraints with different hashes in the same transaction.") // The HashAttachmentConstraint is the strongest constraint, so it wins when mixed with anything. As long as the actual constraints pass. // Migration from HashAttachmentConstraint to SignatureAttachmentConstraint is handled in [TransactionBuilder.handleContract] // If we have reached this point, then no migration is possible and the existing HashAttachmentConstraint must be used constraints.any { it is HashAttachmentConstraint } -&gt; constraints.find { it is HashAttachmentConstraint }!! // TODO, we don't currently support mixing signature constraints with different signers. This will change once we introduce third party signers. constraints.count { it is SignatureAttachmentConstraint } &gt; 1 -&gt; throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.") // This ensures a smooth migration from a Whitelist Constraint to a Signature Constraint constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse) // This condition is hit when the current node has not installed the latest signed version but has already received states that have been migrated constraints.any { it is SignatureAttachmentConstraint } &amp;&amp; !attachmentToUse.isSigned -&gt; throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.") // When all input states have the same constraint. constraints.size == 1 -&gt; constraints.single() else -&gt; throw IllegalArgumentException("Unexpected constraints $constraints.") }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val inputsAndOutputs = (inputStates ?: emptyList()) + (outputStates ?: emptyList()) fun selectAttachment() = getInstalledContractAttachmentId( contractClassName, inputsAndOutputs.filterNot { it.constraint in automaticConstraints }, services ) /* This block handles the very specific code path where a [HashAttachmentConstraint] can migrate to a [SignatureAttachmentConstraint]. If all the criteria is met, this function will return early as the rest of the logic is no longer required. This can only happen in a private network where all nodes have started with a system parameter that disables the hash constraint check. */ if (canMigrateFromHashToSignatureConstraint(inputStates, outputStates, services)) { val attachmentId = selectAttachment() val attachment = services.attachments.openAttachment(attachmentId) require(attachment != null) { "Contract attachment $attachmentId for $contractClassName is missing." } if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates } } // Determine if there are any HashConstraints that pin the version of a contract. If there are, check if we trust them. val hashAttachments = inputsAndOutputs .filter { it.constraint is HashAttachmentConstraint } .map { state -&gt; val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId) if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) } attachment }.toSet() // Check that states with the HashConstraint don't conflict between themselves or with an explicitly set attachment. require(hashAttachments.size &lt;= 1) { "Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code." } if (explicitContractAttachment != null &amp;&amp; hashAttachments.singleOrNull() != null) { require(explicitContractAttachment == (hashAttachments.single() as ContractAttachment).attachment.id) { "An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state." } } // This will contain the hash of the JAR that *has* to be used by this Transaction, because it is explicit. Or null if none. val forcedAttachmentId = explicitContractAttachment ?: hashAttachments.singleOrNull()?.id // This will contain the hash of the JAR that will be used by this Transaction. val selectedAttachmentId = forcedAttachmentId ?: selectAttachment() val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.") // For Exit transactions (no output states) there is no need to resolve the output constraints. if (outputStates == null) { return Pair(selectedAttachmentId, null) } // If there are no automatic constraints, there is nothing to resolve. if (outputStates.none { it.constraint in automaticConstraints }) { return Pair(selectedAttachmentId, outputStates) } // The final step is to resolve AutomaticPlaceholderConstraint. val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader) // When automaticConstraintPropagation is disabled for a contract, output states must an explicit Constraint. require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." } // This is the logic to determine the constraint which will replace the AutomaticPlaceholderConstraint. val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services) // Sanity check that the selected attachment actually passes. val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations) require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" } val resolvedOutputStates = outputStates.map { val outputConstraint = it.constraint if (outputConstraint in automaticConstraints) { it.copy(constraint = defaultOutputConstraint) } else { // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it } } return Pair(selectedAttachmentId, resolvedOutputStates) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint // If there were states transitioned already used in the current transaction use that signature constraint, otherwise create a new one. return when { signatureConstraint != null -&gt; signatureConstraint else -&gt; makeSignatureAttachmentConstraint(attachmentToUse.signerKeys) } }</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature : DigitalSignature</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$ @Throws(InvalidKeyException::class, SignatureException::class) fun verify(txId: SecureHash)</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$/** * Construct a [TransactionSignature] with [partialMerkleTree] set to null. * This is the recommended constructor when signing over a single transaction. * */ constructor(bytes: ByteArray, by: PublicKey, signatureMetadata: SignatureMetadata) : this(bytes, by, signatureMetadata, null)</ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$/** * All contract states may be _encumbered_ by up to one other state. * * The encumbrance state, if present, forces additional controls over the encumbered state, since the platform checks * that the encumbrance state is present as an input in the same transaction that consumes the encumbered state, and * the contract code and rules of the encumbrance state will also be verified during the execution of the transaction. * For example, a cash contract state could be encumbered with a time-lock contract state; the cash state is then only * processable in a transaction that verifies that the time specified in the encumbrance time-lock has passed. * * The encumbered state refers to another by index, and the referred encumbrance state * is an output state in a particular position on the same transaction that created the encumbered state. An alternative * implementation would be encumbering by reference to a [StateRef], which would allow the specification of encumbrance * by a state created in a prior transaction. * * Note that an encumbered state that is being consumed must have its encumbrance consumed in the same transaction, * otherwise the transaction is not valid. */ val encumbrance: Int? = null</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun isAttachmentTrusted(attachment: Attachment, service: AttachmentStorage?): Boolean</ID>
    <ID>MaxLineLength:TransactionUtils.kt$"Invalid Transaction. Sizes of CommandData (${commandDataList.size}) and Signers (${signersList.size}) do not match"</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ContractUpgradeTransactionBuilder$val components = listOf(inputs, notary, legacyContractAttachmentId, upgradedContractClassName, upgradedContractAttachmentId, networkParametersHash).map { it.serialize() }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$SerializedStateAndRef$@KeepForDJVM data</ID>
    <ID>MaxLineLength:TransactionUtils.kt$check(leafIndices.max()!! &lt; signersList.size) { "Invalid Transaction. A command with no corresponding signer detected" }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (attachments.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.ATTACHMENTS_GROUP.ordinal, attachments.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.COMMANDS_GROUP.ordinal, commands.map { it.value }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.SIGNERS_GROUP.ordinal, commands.map { it.signers }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (inputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.INPUTS_GROUP.ordinal, inputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (networkParametersHash != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.PARAMETERS_GROUP.ordinal, listOf(networkParametersHash.serialize())))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (notary != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.NOTARY_GROUP.ordinal, listOf(notary).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (outputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.OUTPUTS_GROUP.ordinal, outputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (references.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.REFERENCES_GROUP.ordinal, references.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (timeWindow != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.TIMEWINDOW_GROUP.ordinal, listOf(timeWindow).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash")</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val commandDataList: List&lt;CommandData&gt; = deserialiseComponentGroup(componentGroups, CommandData::class, ComponentGroupEnum.COMMANDS_GROUP, forceDeserialize)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val componentHashes = group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val signersList: List&lt;List&lt;PublicKey&gt;&gt; = uncheckedCast(deserialiseComponentGroup(componentGroups, List::class, ComponentGroupEnum.SIGNERS_GROUP, forceDeserialize))</ID>
    <ID>MaxLineLength:TransactionUtils.kt${ // Transactions created on Corda 3.x or below do not contain network parameters, // so no checking is done until the minimum platform version is at least 4. if (networkParametersHash == null) { if (serviceHub.networkParameters.minimumPlatformVersion &lt; 4) return else throw IllegalArgumentException("Transaction for notarisation doesn't contain network parameters hash.") } else { serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash") } // TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay. // We will never end up in perfect synchronization with all the nodes. However, network parameters update process // lets us predict what is the reasonable time window for changing parameters on most of the nodes. // For now we don't check whether the attached network parameters match the current ones. }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionResolutionException$@KeepForDJVM open</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConflictingAttachmentsRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConstraintPropagationRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractCreationError : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$Direction</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidAttachmentException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidNotaryChange : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$MissingAttachmentRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$MissingNetworkParametersException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$NotaryChangeInWrongTransactionType : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$OverlappingAttachmentsException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$PackageOwnershipException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$SignersMissing : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionContractConflictException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNetworkParameterOrderingException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNotaryMismatchEncumbranceException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$UntrustedAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException${ /** * Indicates that one of the [Contract.verify] methods selected by the contract constraints and attachments * rejected the transaction by throwing an exception. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractRejection internal constructor(txId: SecureHash, val contractClass: String, cause: Throwable?, message: String) : TransactionVerificationException(txId, "Contract verification failed: $message, contract: $contractClass", cause) { internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "") } /** * This exception happens when a transaction was not built correctly. * When a contract is not annotated with [NoConstraintPropagation], then the platform ensures that the constraints of output states transition correctly from input states. * * @property txId The transaction. * @property contractClass The fully qualified class name of the failing contract. * @property inputConstraint The constraint of the input state. * @property outputConstraint The constraint of the outputs state. */ @KeepForDJVM class ConstraintPropagationRejection(txId: SecureHash, val contractClass: String, inputConstraint: AttachmentConstraint, outputConstraint: AttachmentConstraint) : TransactionVerificationException(txId, "Contract constraints for $contractClass are not propagated correctly. The outputConstraint: $outputConstraint is not a valid transition from the input constraint: $inputConstraint.", null) /** * The transaction attachment that contains the [contractClass] class didn't meet the constraints specified by * the [TransactionState.constraint] object. This usually implies a version mismatch of some kind. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractConstraintRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for $contractClass", null) /** * A state requested a contract class via its [TransactionState.contract] field that didn't appear in any attached * JAR at all. This usually implies the attachments were forgotten or a version mismatch. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class MissingAttachmentRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed, could not find attachment for: $contractClass", null) /** * Indicates this transaction violates the "no overlap" rule: two attachments are trying to provide the same file * path. Whereas Java classpaths would normally allow that with the first class taking precedence, this is not * allowed in transactions for security reasons. This usually indicates that two separate apps share a dependency, * in which case you could try 'shading the fat jars' to rename classes of dependencies. Or you could manually * attach dependency JARs when building the transaction. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ConflictingAttachmentsRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for: $contractClass, because multiple attachments providing this contract were attached.", null) /** * Indicates that the same attachment has been added multiple times to a transaction. */ @KeepForDJVM class DuplicateAttachmentsRejection(txId: SecureHash, val attachmentId: Attachment) : TransactionVerificationException(txId, "The attachment: $attachmentId was added multiple times.", null) /** * A [Contract] class named by a state could not be constructed. Most likely you do not have a no-argument * constructor, or the class doesn't subclass [Contract]. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractCreationError internal constructor(txId: SecureHash, val contractClass: String, cause: Throwable?, message: String) : TransactionVerificationException(txId, "Contract verification failed: $message, could not create contract class: $contractClass", cause) { internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "") } /** * An output state has a notary that doesn't match the transaction's notary field. It must! * * @property txNotary the [Party] specified by the transaction header. * @property outputNotary the [Party] specified by the errant state. */ @KeepForDJVM class NotaryChangeInWrongTransactionType(txId: SecureHash, val txNotary: Party, val outputNotary: Party) : TransactionVerificationException(txId, "Found unexpected notary change in transaction. Tx notary: $txNotary, found: $outputNotary", null) /** * If a state is encumbered (the [TransactionState.encumbrance] field is set) then its encumbrance must be used * as an input to any transaction that uses it. In this way states can be tied together in chains, thus composing * logic. Note that encumbrances aren't fully supported by all aspects of the platform at this time so if you use * them, you may find transactions created by the platform don't always respect the encumbrance rule. * * @property missing the index of the state missing the encumbrance. * @property inOut whether the issue exists in the input list or output list. */ @KeepForDJVM class TransactionMissingEncumbranceException(txId: SecureHash, val missing: Int, val inOut: Direction) : TransactionVerificationException(txId, "Missing required encumbrance $missing in $inOut", null) /** * If two or more states refer to another state (as their encumbrance), then the bi-directionality property cannot * be satisfied. */ @KeepForDJVM class TransactionDuplicateEncumbranceException(txId: SecureHash, index: Int) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Index $index is referenced more than once", null) /** * An encumbered state should also be referenced as the encumbrance of another state in order to satisfy the * bi-directionality property (a full cycle should be present). */ @KeepForDJVM class TransactionNonMatchingEncumbranceException(txId: SecureHash, nonMatching: Collection&lt;Int&gt;) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form " + "a full cycle. Offending indices $nonMatching", null) /** * All encumbered states should be assigned to the same notary. This is due to the fact that multi-notary * transactions are not supported and thus two encumbered states with different notaries cannot be consumed * in the same transaction. */ @KeepForDJVM class TransactionNotaryMismatchEncumbranceException(txId: SecureHash, encumberedIndex: Int, encumbranceIndex: Int, encumberedNotary: Party, encumbranceNotary: Party) : TransactionVerificationException(txId, "Encumbered output states assigned to different notaries found. " + "Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]", null) /** * If a state is identified as belonging to a contract, either because the state class is defined as an inner class * of the contract class or because the state class is annotated with [BelongsToContract], then it must not be * bundled in a [TransactionState] with a different contract. * * @param state The [TransactionState] whose bundled state and contract are in conflict. * @param requiredContractClassName The class name of the contract to which the state belongs. */ @KeepForDJVM class TransactionContractConflictException(txId: SecureHash, state: TransactionState&lt;ContractState&gt;, requiredContractClassName: String) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} belongs to contract $requiredContractClassName, but is bundled in TransactionState with ${state.contract}. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent().replace('\n', ' '), null) // TODO: add reference to documentation @KeepForDJVM class TransactionRequiredContractUnspecifiedException(txId: SecureHash, state: TransactionState&lt;ContractState&gt;) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} does not have a specified owning contract. Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState with the correct contract. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent(), null) /** * If the network parameters associated with an input or reference state in a transaction are more recent than the network parameters of the new transaction itself. */ @KeepForDJVM class TransactionNetworkParameterOrderingException(txId: SecureHash, inputStateRef: StateRef, txnNetworkParameters: NetworkParameters, inputNetworkParameters: NetworkParameters) : TransactionVerificationException(txId, "The network parameters epoch (${txnNetworkParameters.epoch}) of this transaction " + "is older than the epoch (${inputNetworkParameters.epoch}) of input state: $inputStateRef", null) /** * Thrown when the network parameters with hash: missingNetworkParametersHash is not available at this node. Usually all the parameters * that are in the resolution chain for transaction with txId should be fetched from peer via [FetchParametersFlow] or from network map. * * @param txId Id of the transaction that has missing parameters hash in the resolution chain * @param missingNetworkParametersHash Missing hash of the network parameters associated to this transaction */ @KeepForDJVM class MissingNetworkParametersException(txId: SecureHash, missingNetworkParametersHash: SecureHash) : TransactionVerificationException(txId, "Couldn't find network parameters with hash: $missingNetworkParametersHash related to this transaction: $txId", null) /** Whether the inputs or outputs list contains an encumbrance issue, see [TransactionMissingEncumbranceException]. */ @CordaSerializable @KeepForDJVM enum class Direction { /** Issue in the inputs list. */ INPUT, /** Issue in the outputs list. */ OUTPUT } // We could revisit and throw this more appropriate type in a future release that uses targetVersion to // avoid the compatibility break, because IllegalStateException isn't ideal for this. Or we could use this // as a cause. /** @suppress This class is not used: duplicate inputs throw a [IllegalStateException] instead. */ @Deprecated("This class is not used: duplicate inputs throw a [IllegalStateException] instead.") @DeleteForDJVM class DuplicateInputStates(txId: SecureHash, val duplicates: NonEmptySet&lt;StateRef&gt;) : TransactionVerificationException(txId, "Duplicate inputs: ${duplicates.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class MoreThanOneNotary(txId: SecureHash) : TransactionVerificationException(txId, "More than one notary", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class SignersMissing(txId: SecureHash, val missing: List&lt;PublicKey&gt;) : TransactionVerificationException(txId, "Signers missing: ${missing.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class InvalidNotaryChange(txId: SecureHash) : TransactionVerificationException(txId, "Detected a notary change. Outputs must use the same notary as inputs", null) /** * Thrown when multiple attachments provide the same file when building the AttachmentsClassloader for a transaction. */ @KeepForDJVM class OverlappingAttachmentsException(txId: SecureHash, val path: String) : TransactionVerificationException(txId, "Multiple attachments define a file at $path.", null) /** * Thrown to indicate that a contract attachment is not signed by the network-wide package owner. Please note that * the [txId] will always be [SecureHash.zeroHash] because package ownership is an error with a particular attachment, * and because attachment classloaders are reused this is independent of any particular transaction. */ class PackageOwnershipException(txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId, @Suppress("unused") val invalidClassName: String, val packageName: String) : TransactionVerificationException(txId, """The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters""".trimIndent(), null) class InvalidAttachmentException(txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId) : TransactionVerificationException(txId, "The attachment $attachmentHash is not a valid ZIP or JAR file.".trimIndent(), null) // TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized. /** Thrown during classloading upon encountering an untrusted attachment (eg. not in the [TRUSTED_UPLOADERS] list) */ @KeepForDJVM class UntrustedAttachmentsException(val txId: SecureHash, val ids: List&lt;SecureHash&gt;) : CordaException("Attempting to load untrusted transaction attachments: $ids. " + "At this time these are not loadable because the DJVM sandbox has not yet been integrated. " + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") /* If you add a new class extending [TransactionVerificationException], please add a test in `TransactionVerificationExceptionSerializationTests` proving that it can actually be serialised. As a rule, exceptions intended to be serialised _must_ have a corresponding readable property for every named constructor parameter - so make your constructor parameters `val`s even if nothing other than the serializer is ever going to read them. */ }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractCreationError$internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractRejection$internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$ Please check the source of this attachment and if it is malicious contact your zone operator to report this incident.</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$"""The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters"""</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNonMatchingEncumbranceException$"is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form "</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNotaryMismatchEncumbranceException$"Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]"</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$ Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.UntrustedAttachmentsException$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$net.corda.core.contracts.TransactionVerificationException.kt</ID>
    <ID>MaxLineLength:TransactionVerifierService.kt$TransactionVerifierService$ fun verify(transaction: LedgerTransaction): CordaFuture&lt;*&gt;</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ State of class </ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun validateStatesAgainstContract()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraints(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$?:</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$checkMinimumPlatformVersion(ltx.networkParameters?.minimumPlatformVersion ?: 1, 4, "Signature constraints")</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$contractAttachmentsPerContract .groupBy { it.first } // Group by contract. .filter { (_, attachments) -&gt; attachments.size &gt; 1 }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (contractWithMultipleAttachments != null) throw TransactionVerificationException.ConflictingAttachmentsRejection(ltx.id, contractWithMultipleAttachments)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (ltx.attachments.size != ltx.attachments.toSet().size) throw TransactionVerificationException.DuplicateAttachmentsRejection(ltx.id, ltx.attachments.groupBy { it }.filterValues { it.size &gt; 1 }.keys.first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (result.keys != contractClasses) throw TransactionVerificationException.MissingAttachmentRejection(ltx.id, contractClasses.minus(result.keys).first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.NotaryChangeInWrongTransactionType(ltx.id, ltx.notary, it.notary)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.TransactionNonMatchingEncumbranceException(ltx.id, symmetricDifference)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val constraintAttachment = AttachmentWithContext(contractAttachment, contract, ltx.networkParameters!!.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ // checkNoNotaryChange and checkEncumbrancesValid are called here, and not in the c'tor, as they need access to the "outputs" // list, the contents of which need to be deserialized under the correct classloader. checkNoNotaryChange() checkEncumbrancesValid() // The following checks ensure the integrity of the current transaction and also of the future chain. // See: https://docs.corda.net/head/api-contract-constraints.html // A transaction contains both the data and the code that must be executed to validate the transition of the data. // Transactions can be created by malicious adversaries, who can try to use code that allows them to create transactions that appear valid but are not. // 1. Check that there is one and only one attachment for each relevant contract. val contractAttachmentsByContract = getUniqueContractAttachmentsByContract() // 2. Check that the attachments satisfy the constraints of the states. (The contract verification code is correct.) verifyConstraints(contractAttachmentsByContract) // 3. Check that the actual state constraints are correct. This is necessary because transactions can be built by potentially malicious nodes // who can create output states with a weaker constraint which can be exploited in a future transaction. verifyConstraintsValidity(contractAttachmentsByContract) // 4. Check that the [TransactionState] objects are correctly formed. validateStatesAgainstContract() // 5. Final step is to run the contract code. After the first 4 steps we are now sure that we are running the correct code. verifyContracts() }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ if (!contractClassName.contractHasAutomaticConstraintPropagation(transactionClassLoader)) { contractClassName.warnContractWithoutConstraintPropagation() continue } val contractAttachment = contractAttachmentsByContract[contractClassName]!! // Verify that the constraints of output states have at least the same level of restriction as the constraints of the // corresponding input states. val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet() val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet() outputConstraints.forEach { outputConstraint -&gt; inputConstraints.forEach { inputConstraint -&gt; if (!(outputConstraint.canBeTransitionedFrom(inputConstraint, contractAttachment))) { throw TransactionVerificationException.ConstraintPropagationRejection( ltx.id, contractClassName, inputConstraint, outputConstraint) } } } }</ID>
    <ID>MaxLineLength:TransactionWithSignatures.kt$TransactionWithSignatures${ val sigKeys = sigs.map { it.by }.toSet() // TODO Problem is that we can get single PublicKey wrapped as CompositeKey in allowedToBeMissing/mustSign // equals on CompositeKey won't catch this case (do we want to single PublicKey be equal to the same key wrapped in CompositeKey with threshold 1?) return requiredSigningKeys.filter { !it.isFulfilledBy(sigKeys) }.toSet() }</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnFailure(action: Consumer&lt;Throwable&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnSuccess(action: Consumer&lt;in A&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ inline fun &lt;B&gt; flatMap(function: (A) -&gt; Try&lt;B&gt;): Try&lt;B&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try.Companion$ @JvmStatic inline fun &lt;T&gt; on(body: () -&gt; T): Try&lt;T&gt;</ID>
    <ID>MaxLineLength:UniqueIdentifier.kt$UniqueIdentifier$@CordaSerializable @KeepForDJVM data</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.doOnError(action: (Throwable) -&gt; Unit): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.mapErrors(transform: (Throwable) -&gt; Throwable): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$StatesNotAvailableException : FlowException</ID>
    <ID>MaxLineLength:VaultService.kt$Vault$Update&lt;U : ContractState&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Companion$@Deprecated("No longer used. The vault does not emit empty updates") val NoNotaryUpdate = Vault.Update(emptySet(), emptySet(), type = Vault.UpdateType.NOTARY_CHANGE, references = emptySet())</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, null)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, relevancyStatus, ConstraintInfo(AlwaysAcceptAttachmentConstraint))</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$ operator fun plus(rhs: Update&lt;U&gt;): Update&lt;U&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$/** * Specifies the type of update, currently supported types are general and, contract upgrade and notary change. * Notary change transactions only modify the notary field on states, and potentially need to be handled * differently. */ val type: UpdateType = UpdateType.GENERAL</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$inline</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update${ require(rhs.type == type) { "Cannot combine updates of different types" } val combinedConsumed = consumed + (rhs.consumed - produced) // The ordering below matters to preserve ordering of consumed/produced Sets when they are insertion order dependent implementations. val combinedProduced = produced.filter { it !in rhs.consumed }.toSet() + rhs.produced return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references) }</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Suspendable @Throws(StatesNotAvailableException::class) fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending(lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$/** * Prefer the use of [updates] unless you know why you want to use this instead. * * Get a synchronous [Observable] of updates. When observations are pushed to the Observer, the [Vault] will already * incorporate the update, and the database transaction associated with the update will still be open and current. * If for some reason the processing crosses outside of the database transaction (for example, the update is pushed * outside the current JVM or across to another [Thread], which is executing in a different database transaction), * then the [Vault] may not incorporate the update due to racing with committing the current database transaction. */ val rawUpdates: Observable&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$doneFuture(Vault.Update(consumed = setOf(snapshot.single()), produced = emptySet(), references = emptySet()))</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$inline</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$( inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt() )</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$( resolveIdentity, resolveAttachment, { stateRef -&gt; resolveStateRef(stateRef)?.serialize() }, { null }, // Returning a dummy `missingAttachment` Attachment allows this deprecated method to work and it disables "contract version no downgrade rule" as a dummy Attachment returns version 1 { resolveAttachment(it.txhash) ?: missingAttachment }, { isAttachmentTrusted(it, null) } )</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Builds whole Merkle tree for a transaction. * Briefly, each component group has its own sub Merkle tree and all of the roots of these trees are used as leaves * in a top level Merkle tree. * Note that ordering of elements inside a [ComponentGroup] matters when computing the Merkle root. * On the other hand, insertion group ordering does not affect the top level Merkle tree construction, as it is * actually an ordered Merkle tree, where its leaves are ordered based on the group ordinal in [ComponentGroupEnum]. * If any of the groups is an empty list or a null object, then [SecureHash.allOnesHash] is used as its hash. * Also, [privacySalt] is not a Merkle tree leaf, because it is already "inherently" included via the component nonces. */ val merkleTree: MerkleTree by lazy { MerkleTree.getMerkleTree(groupHashes) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Calculate nonces for every transaction component, including new fields (due to backwards compatibility support) we cannot process. * Nonce are computed in the following way: * nonce1 = H(salt || path_for_1st_component) * nonce2 = H(salt || path_for_2nd_component) * etc. * Thus, all of the nonces are "independent" in the sense that knowing one or some of them, you can learn * nothing about the rest. */ internal val availableComponentNonces: Map&lt;Int, List&lt;SecureHash&gt;&gt; by lazy { componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap() }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * The leaves (group hashes) of the top level Merkle tree. * If a group's Merkle root is allOnesHash, it is a flag that denotes this group is empty (if list) or null (if single object) * in the wire transaction. */ internal val groupHashes: List&lt;SecureHash&gt; by lazy { val listOfLeaves = mutableListOf&lt;SecureHash&gt;() // Even if empty and not used, we should at least send oneHashes for each known // or received but unknown (thus, bigger than known ordinal) component groups. for (i in 0..componentGroups.map { it.groupIndex }.max()!!) { val root = groupsMerkleRoots[i] ?: SecureHash.allOnesHash listOfLeaves.add(root) } listOfLeaves }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$// This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$ReplaceWith("WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$SerializedStateAndRef(resolveStateRefAsSerialized(ref) ?: throw TransactionResolutionException(ref.txhash), ref)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(componentGroups.map { it.groupIndex }.toSet().size == componentGroups.size) { "Duplicated component groups detected" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(inputs.isNotEmpty() || outputs.isNotEmpty()) { "A transaction must contain at least one input or output state" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$checkTransactionSize(ltx, resolvedNetworkParameters.maxTransactionSize, serializedResolvedInputs, serializedResolvedReferences)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(availableComponentNonces[it.groupIndex]!![internalIndex], internalIt) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedAttachments = attachments.lazyMapped { att, _ -&gt; resolveAttachment(att) ?: throw AttachmentResolutionException(att) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedNetworkParameters = resolveParameters(networkParametersHash) ?: throw TransactionResolutionException.UnknownParametersException(id, networkParametersHash!!)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction${ var remainingTransactionSize = maxTransactionSize fun minus(size: Int) { require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." } remainingTransactionSize -= size } // This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int { return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0 } // Check attachments size first as they are most likely to go over the limit. With ContractAttachment instances // it's likely that the same underlying Attachment CorDapp will occur more than once so we dedup on the attachment id. ltx.attachments.distinctBy { it.id }.forEach { minus(it.size) } minus(resolvedSerializedInputs.sumBy { it.serializedState.size }) minus(resolvedSerializedReferences.sumBy { it.serializedState.size }) // For Commands and outputs we can use the component groups as they are already serialized. minus(componentGroupSize(COMMANDS_GROUP)) minus(componentGroupSize(OUTPUTS_GROUP)) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$?:</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$else -&gt; throw UnsupportedOperationException("Attempting to resolve input ${stateRef.index} of a ${coreTransaction.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$is ContractUpgradeWireTransaction -&gt; coreTransaction.resolveOutputComponent(services, stateRef, params)</ID>
    <ID>MaxLineLength:WithReferencedStatesFlow.kt$WithReferencedStatesFlow&lt;T : Any&gt; : FlowLogic</ID>
    <ID>MaxLineLength:X500Utils.kt$ fun X500Principal.toAttributesMap(supportedAttributes: Set&lt;ASN1ObjectIdentifier&gt; = emptySet()): Map&lt;ASN1ObjectIdentifier, String&gt;</ID>
    <ID>NestedBlockDepth:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>NestedBlockDepth:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:FetchDataFlow.kt$FetchAttachmentsFlow$override fun maybeWriteToDisk(downloaded: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:InternalUtils.kt$ inline fun &lt;T&gt; Iterable&lt;T&gt;.noneOrSingle(predicate: (T) -&gt; Boolean): T?</ID>
    <ID>NestedBlockDepth:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>NewLineAtEndOfFile:AbstractParty.kt$net.corda.core.identity.AbstractParty.kt</ID>
    <ID>NewLineAtEndOfFile:AddressBindingException.kt$net.corda.core.internal.errors.AddressBindingException.kt</ID>
    <ID>NewLineAtEndOfFile:AnonymousParty.kt$net.corda.core.identity.AnonymousParty.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentWithContext.kt$net.corda.core.internal.AttachmentWithContext.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentsClassLoader.kt$net.corda.core.serialization.internal.AttachmentsClassLoader.kt</ID>
    <ID>NewLineAtEndOfFile:BaseTransaction.kt$net.corda.core.transactions.BaseTransaction.kt</ID>
    <ID>NewLineAtEndOfFile:BaseTransactions.kt$net.corda.core.transactions.BaseTransactions.kt</ID>
    <ID>NewLineAtEndOfFile:CheckpointSerializationAPI.kt$net.corda.core.serialization.internal.CheckpointSerializationAPI.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRelevantError.kt$net.corda.core.ClientRelevantError.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRpcSslOptions.kt$net.corda.core.messaging.ClientRpcSslOptions.kt</ID>
    <ID>NewLineAtEndOfFile:CommonSchema.kt$net.corda.core.schemas.CommonSchema.kt</ID>
    <ID>NewLineAtEndOfFile:CompositeSignature.kt$net.corda.core.crypto.CompositeSignature.kt</ID>
    <ID>NewLineAtEndOfFile:ConstructorForDeserialization.kt$net.corda.core.serialization.ConstructorForDeserialization.kt</ID>
    <ID>NewLineAtEndOfFile:ContractUpgradeTransactions.kt$net.corda.core.transactions.ContractUpgradeTransactions.kt</ID>
    <ID>NewLineAtEndOfFile:ContractUpgradeUtils.kt$net.corda.core.internal.ContractUpgradeUtils.kt</ID>
    <ID>NewLineAtEndOfFile:CordaException.kt$net.corda.core.CordaException.kt</ID>
    <ID>NewLineAtEndOfFile:CordaInternal.kt$net.corda.core.CordaInternal.kt</ID>
    <ID>NewLineAtEndOfFile:CordaX500Name.kt$net.corda.core.identity.CordaX500Name.kt</ID>
    <ID>NewLineAtEndOfFile:CordappConfig.kt$net.corda.core.cordapp.CordappConfig.kt</ID>
    <ID>NewLineAtEndOfFile:CordappInfo.kt$net.corda.core.cordapp.CordappInfo.kt</ID>
    <ID>NewLineAtEndOfFile:CordappProvider.kt$net.corda.core.cordapp.CordappProvider.kt</ID>
    <ID>NewLineAtEndOfFile:CordappResolver.kt$net.corda.core.internal.cordapp.CordappResolver.kt</ID>
    <ID>NewLineAtEndOfFile:DigitalSignatureWithCert.kt$net.corda.core.internal.DigitalSignatureWithCert.kt</ID>
    <ID>NewLineAtEndOfFile:DoNotImplement.kt$net.corda.core.DoNotImplement.kt</ID>
    <ID>NewLineAtEndOfFile:FetchDataFlow.kt$net.corda.core.internal.FetchDataFlow.kt</ID>
    <ID>NewLineAtEndOfFile:FlowHandle.kt$net.corda.core.messaging.FlowHandle.kt</ID>
    <ID>NewLineAtEndOfFile:FlowInitiator.kt$net.corda.core.flows.FlowInitiator.kt</ID>
    <ID>NewLineAtEndOfFile:FlowLogicRef.kt$net.corda.core.flows.FlowLogicRef.kt</ID>
    <ID>NewLineAtEndOfFile:FlowStackSnapshot.kt$net.corda.core.flows.FlowStackSnapshot.kt</ID>
    <ID>NewLineAtEndOfFile:Id.kt$net.corda.core.utilities.Id.kt</ID>
    <ID>NewLineAtEndOfFile:IdempotentFlow.kt$net.corda.core.internal.IdempotentFlow.kt</ID>
    <ID>NewLineAtEndOfFile:IdentityUtils.kt$net.corda.core.identity.IdentityUtils.kt</ID>
    <ID>NewLineAtEndOfFile:InitiatedBy.kt$net.corda.core.flows.InitiatedBy.kt</ID>
    <ID>NewLineAtEndOfFile:Instances.kt$net.corda.core.crypto.internal.Instances.kt</ID>
    <ID>NewLineAtEndOfFile:InternalCordaRPCOps.kt$net.corda.core.internal.messaging.InternalCordaRPCOps.kt</ID>
    <ID>NewLineAtEndOfFile:InvocationContext.kt$net.corda.core.context.InvocationContext.kt</ID>
    <ID>NewLineAtEndOfFile:JarSignatureCollector.kt$net.corda.core.internal.JarSignatureCollector.kt</ID>
    <ID>NewLineAtEndOfFile:KeepForDJVM.kt$net.corda.core.KeepForDJVM.kt</ID>
    <ID>NewLineAtEndOfFile:KeyManagementService.kt$net.corda.core.node.services.KeyManagementService.kt</ID>
    <ID>NewLineAtEndOfFile:LazyPool.kt$net.corda.core.internal.LazyPool.kt</ID>
    <ID>NewLineAtEndOfFile:LazyStickyPool.kt$net.corda.core.internal.LazyStickyPool.kt</ID>
    <ID>NewLineAtEndOfFile:LegalNameValidator.kt$net.corda.core.internal.LegalNameValidator.kt</ID>
    <ID>NewLineAtEndOfFile:LifeCycle.kt$net.corda.core.internal.LifeCycle.kt</ID>
    <ID>NewLineAtEndOfFile:MerkleTransaction.kt$net.corda.core.transactions.MerkleTransaction.kt</ID>
    <ID>NewLineAtEndOfFile:MerkleTree.kt$net.corda.core.crypto.MerkleTree.kt</ID>
    <ID>NewLineAtEndOfFile:MissingAttachmentsException.kt$net.corda.core.serialization.MissingAttachmentsException.kt</ID>
    <ID>NewLineAtEndOfFile:NodeDiagnosticInfo.kt$net.corda.core.node.NodeDiagnosticInfo.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryService.kt$net.corda.core.internal.notary.NotaryService.kt</ID>
    <ID>NewLineAtEndOfFile:NullKeys.kt$net.corda.core.crypto.NullKeys.kt</ID>
    <ID>NewLineAtEndOfFile:ProgressTracker.kt$net.corda.core.internal.ProgressTracker.kt</ID>
    <ID>NewLineAtEndOfFile:QueryCriteriaUtils.kt$net.corda.core.node.services.vault.QueryCriteriaUtils.kt</ID>
    <ID>NewLineAtEndOfFile:RPCOps.kt$net.corda.core.messaging.RPCOps.kt</ID>
    <ID>NewLineAtEndOfFile:RPCReturnsObservables.kt$net.corda.core.messaging.RPCReturnsObservables.kt</ID>
    <ID>NewLineAtEndOfFile:SchedulableFlow.kt$net.corda.core.flows.SchedulableFlow.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationAnnotations.kt$net.corda.core.serialization.SerializationAnnotations.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationWhitelist.kt$net.corda.core.serialization.SerializationWhitelist.kt</ID>
    <ID>NewLineAtEndOfFile:ServiceHubCoreInternal.kt$net.corda.core.internal.ServiceHubCoreInternal.kt</ID>
    <ID>NewLineAtEndOfFile:StartableByRPC.kt$net.corda.core.flows.StartableByRPC.kt</ID>
    <ID>NewLineAtEndOfFile:StartableByService.kt$net.corda.core.flows.StartableByService.kt</ID>
    <ID>NewLineAtEndOfFile:StateMachineRunId.kt$net.corda.core.flows.StateMachineRunId.kt</ID>
    <ID>NewLineAtEndOfFile:StatePointer.kt$net.corda.core.contracts.StatePointer.kt</ID>
    <ID>NewLineAtEndOfFile:StatePointerSearch.kt$net.corda.core.internal.StatePointerSearch.kt</ID>
    <ID>NewLineAtEndOfFile:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>NewLineAtEndOfFile:TimeWindow.kt$net.corda.core.contracts.TimeWindow.kt</ID>
    <ID>NewLineAtEndOfFile:Trace.kt$net.corda.core.context.Trace.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionStorage.kt$net.corda.core.node.services.TransactionStorage.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionVerifierService.kt$net.corda.core.node.services.TransactionVerifierService.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionWithSignatures.kt$net.corda.core.transactions.TransactionWithSignatures.kt</ID>
    <ID>NewLineAtEndOfFile:UniqueIdentifier.kt$net.corda.core.contracts.UniqueIdentifier.kt</ID>
    <ID>NewLineAtEndOfFile:UuidGenerator.kt$net.corda.core.utilities.UuidGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:VaultService.kt$net.corda.core.node.services.VaultService.kt</ID>
    <ID>ReturnCount:Amount.kt$Amount.Companion$ @JvmStatic fun getDisplayTokenSize(token: Any): BigDecimal</ID>
    <ID>ReturnCount:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun containsClasses(attachment: Attachment): Boolean</ID>
    <ID>ReturnCount:ByteArrays.kt$fun hexToBin(ch: Char): Int</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Custom key pair generator from an entropy required for various tests. It is similar to deriveKeyPairECDSA, // but the accepted range of the input entropy is more relaxed: // 2 &lt;= entropy &lt; N, where N is the order of base-point G. private fun deriveECDSAKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Given the domain parameters, this routine deterministically generates an ECDSA key pair // in accordance with X9.62 section 5.2.1 pages 26, 27. private fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>ReturnCount:Emoji.kt$Emoji$fun renderIfSupported(obj: Any): String</ID>
    <ID>ReturnCount:PartialMerkleTree.kt$PartialMerkleTree$// Helper function to compute the path. False means go to the left and True to the right. // Because the path is updated recursively, the path is returned in reverse order. private fun leafIndexHelper(leaf: SecureHash, node: PartialTree, path: MutableList&lt;Boolean&gt;): Boolean</ID>
    <ID>ReturnCount:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ReturnCount:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>SpreadOperator:AbstractParty.kt$AbstractParty$(*bytes)</ID>
    <ID>SpreadOperator:ByteArrays.kt$OpaqueBytes.Companion$(*b)</ID>
    <ID>SpreadOperator:CollectSignaturesFlow.kt$CollectSignatureFlow$(*signingKeys)</ID>
    <ID>SpreadOperator:CompositeKey.kt$CompositeKey.Builder$(*keys.toTypedArray())</ID>
    <ID>SpreadOperator:CordaX500Name.kt$CordaX500Name.Companion$(*Locale.getISOCountries(), unspecifiedCountry)</ID>
    <ID>SpreadOperator:InternalUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(*options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(parent / fileName, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *attrs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, BasicFileAttributes::class.java, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, bytes, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, lines, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, maxDepth, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, targetFile, *options)</ID>
    <ID>SpreadOperator:ProgressTracker.kt$ProgressTracker$(UNSTARTED, STARTING, *inputSteps, DONE)</ID>
    <ID>SpreadOperator:ServiceHub.kt$ServiceHub$(first, *remaining)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*keys)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*types)</ID>
    <ID>SpreadOperator:TransactionWithSignatures.kt$TransactionWithSignatures$(*allowedToBeMissing)</ID>
    <ID>SpreadOperator:WaitForStateConsumption.kt$WaitForStateConsumption$(*futures.toTypedArray())</ID>
    <ID>ThrowsCount:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>ThrowsCount:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$@DeleteForDJVM private fun resolveAndCheckNetworkParameters(services: ServiceHub)</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun getUniqueContractAttachmentsByContract(): Map&lt;ContractClassName, ContractAttachment&gt;</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyContracts()</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, resolveContractAttachment: (StateRef) -&gt; Attachment, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>TooGenericExceptionCaught:Amount.kt$Amount.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CertRole.kt$CertRole.Companion$ex: ArrayIndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:CollectSignaturesFlow.kt$SignTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConcurrencyUtils.kt$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$CordaFutureImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$ValueOrException$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowHandle.kt$FlowProgressHandleImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:MerkleTransaction.kt$FilteredTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryServiceFlow.kt$NotaryServiceFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionBuilder.kt$TransactionBuilder$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionVerifierServiceInternal.kt$Verifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Try.kt$Try.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:X509EdDSAEngine.kt$X509EdDSAEngine$e: Exception</ID>
    <ID>TooGenericExceptionThrown:MerkleTransaction.kt$FilteredTransaction$throw Exception("Malformed transaction, signers at index $internalIndex cannot be deserialised", e)</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${payload::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?")</ID>
    <ID>TooManyFunctions:BaseTransaction.kt$BaseTransaction : NamedByHash</ID>
    <ID>TooManyFunctions:ByteArrays.kt$ByteSequence : Comparable</ID>
    <ID>TooManyFunctions:CompositeKey.kt$CompositeKey : PublicKey</ID>
    <ID>TooManyFunctions:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:CordaFutureImpl.kt$net.corda.core.internal.concurrent.CordaFutureImpl.kt</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$CordaRPCOps : RPCOps</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$net.corda.core.messaging.CordaRPCOps.kt</ID>
    <ID>TooManyFunctions:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>TooManyFunctions:Crypto.kt$Crypto</ID>
    <ID>TooManyFunctions:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>TooManyFunctions:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>TooManyFunctions:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>TooManyFunctions:IdentityService.kt$IdentityService</ID>
    <ID>TooManyFunctions:InternalUtils.kt$net.corda.core.internal.InternalUtils.kt</ID>
    <ID>TooManyFunctions:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>TooManyFunctions:NetworkMapCache.kt$NetworkMapCacheBase</ID>
    <ID>TooManyFunctions:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:PathUtils.kt$net.corda.core.internal.PathUtils.kt</ID>
    <ID>TooManyFunctions:ProgressTracker.kt$ProgressTracker</ID>
    <ID>TooManyFunctions:QueryCriteria.kt$QueryCriteria$VaultQueryCriteria : CommonQueryCriteria</ID>
    <ID>TooManyFunctions:QueryCriteriaUtils.kt$Builder</ID>
    <ID>TooManyFunctions:SerializationAPI.kt$SerializationContext</ID>
    <ID>TooManyFunctions:ServiceHub.kt$ServiceHub : ServicesForResolution</ID>
    <ID>TooManyFunctions:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>TooManyFunctions:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>TooManyFunctions:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>TooManyFunctions:VaultService.kt$VaultService</ID>
    <ID>TooManyFunctions:VaultService.kt$net.corda.core.node.services.VaultService.kt</ID>
    <ID>TooManyFunctions:X509EdDSAEngine.kt$X509EdDSAEngine : Signature</ID>
    <ID>TopLevelPropertyNaming:ConcurrencyUtils.kt$@VisibleForTesting internal const val shortCircuitedTaskFailedMessage = "Short-circuited task failed:"</ID>
    <ID>TopLevelPropertyNaming:ProviderMap.kt$// OID taken from https://tools.ietf.org/html/draft-ietf-curdle-pkix-00 val `id-Curve25519ph` = ASN1ObjectIdentifier("1.3.101.112")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _allEnabledSerializationEnvs: List&lt;Pair&lt;String, SerializationEnvironment&gt;&gt; get() = serializationEnvFields.mapNotNull { it.get()?.let { env -&gt; Pair(it.name, env) } }</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _contextSerializationEnv = ThreadLocalToggleField&lt;SerializationEnvironment&gt;("contextSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _driverSerializationEnv = SimpleToggleField&lt;SerializationEnvironment&gt;("driverSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>WildcardImport:AliasPrivateKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import java.net.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:BaseTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CheckpointSerializationAPI.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:CommonSchema.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CompositeKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:CompositeKeyFactory.kt$import java.security.*</ID>
    <ID>WildcardImport:CompositeSignature.kt$import java.security.*</ID>
    <ID>WildcardImport:ConstraintsUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.transactions.ContractUpgradeWireTransaction.Component.*</ID>
    <ID>WildcardImport:ContractUpgradeUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CordaInternal.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:CordaRPCOps.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:Cordapp.kt$import net.corda.core.cordapp.Cordapp.Info.*</ID>
    <ID>WildcardImport:Crypto.kt$import java.security.*</ID>
    <ID>WildcardImport:Crypto.kt$import net.corda.core.crypto.internal.*</ID>
    <ID>WildcardImport:CryptoUtils.kt$import java.security.*</ID>
    <ID>WildcardImport:DeleteForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:DigitalSignatureWithCert.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:FlowLogic.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowStateMachine.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:IdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.transactions.NotaryChangeWireTransaction.Component.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NotaryServiceFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NotaryUtils.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:PartyAndCertificate.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.io.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.nio.file.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:ReceiveTransactionFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SendTransactionFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:StubOutForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:TransactionVerifierServiceInternal.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.Vault.RelevancyStatus.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:X509EdDSAEngine.kt$import java.security.*</ID>
  </Whitelist>
</SmellBaseline>
